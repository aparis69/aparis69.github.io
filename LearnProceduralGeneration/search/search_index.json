{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the Procedural Generation guide. This is aimed at people that want to learn more about world generation, featuring terrain, ecosystem simulation, river animation, just to name a few. On top of being as accessible as possible to everyone, the goal here is to provide explanations, mathematical formulas, clear code, demos, and exercises for all examples. </p> <p>Interactive demos are made possible thanks to the Three.js library. Only basic knowledge in Programming and Computer Graphics should be required to go through this guide.</p> <p>Warning</p> <p>This guide is currently (as of 2025) being written and is thus a work in progress. Except significant changes, errors, and new content being added. Feedback is welcome.</p>"},{"location":"#what-is-procedural-generation","title":"What is Procedural Generation?","text":"<p>Procedural Generation refers to a way of creating digital content, let it be 3D models, textures, patterns, colors, and so on. The idea is that data is generated more or less  automatically through the use of an algorithm or a procedure, rather than created manually. Generating content procedurally can provide many advantages, including scalability (with the ability to generate a large set of different shapes), memory efficiency (by only storing the generation procedure, and not its output), and a lot more. Procedural generation is a powerful tool that artists use in their day to day life.</p> <p>Computer Graphics has been a great playground for Procedural Generation throughout the years, with the first papers going back to 1990 with Frank Ebert.</p> <p>Note that there is not a single definition for these terms. This is just my personal one and the one that will be used throughout this guide.</p>"},{"location":"#do-i-need-to-know-programming","title":"Do I need to know Programming?","text":"<p>To a certain extent, yes. We will use the Javascript language in all of our examples, which does not involve low-level programming and is probably easier to grasp than C++. Having some very basic notions of Computer Graphics is also a good thing, although each page aims at being self-contained. For the basics, see the Javascript page.</p>"},{"location":"#do-i-need-to-know-math","title":"Do I need to know Math?","text":"<p>Only a very basic knowledge of linear algebra and math is expected. When possible, I provide the equivalence between math and code so that it is accessible to more people. For vector and matrice types, we will extensively use the strutures provided by Three.js, such as Vector2,   Vector3, and Matrix4.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>This guide is separated in multiple parts, each one covering a different aspect of world generation. These are mostly independent and can be read in any order. All sections are illustrated with interactive examples that run directly in your web browser. Small exercises are mentioned at the end of each page, if you want to go deeper into a given topic.</p> <ul> <li>\u26f0\ufe0f Terrain, where you will about the different techniques for generating terrains, including procedural noise and erosion simulation.</li> <li>\ud83d\udcda Fundamentals, which is a general sections in which we explain basic concept used throughout this guide. We often references this section during the guide, so you can just read it as you go along in the main part. It also contains a glossary of all the technical terms.</li> <li>More to come!</li> </ul> <p>The concepts presented in this guide are not new groundbreaking research. Everything has either been published in research papers, used in multiple video games, or written and explained in various blogs. The end goal of this guide is to be as complete as possible and become a go-to reference for Procedural World Generation.</p>"},{"location":"#faq","title":"FAQ","text":"Why another Procedural Generation guide? <p>There are a lot of great resources online to get started - but none of them was interactive and accessible enough for my tastes. In order to be complete, there is a list of references to great external resources in each part of the tutorial.</p> Can I use the code written here? <p>The code that uses Three.js is under MIT License - and the rest, written by me, is released under MIT unless specified otherwise.</p> Why Javascript and not C++? <p>It is true that Computer Graphics topics in general are usually explained in C++, but I wanted this guide to be as interactive as possible, which is easier in Javascript (although I am not a fan nor an expert of this language).</p> I saw an error/a typo. Where can I report it? <p>You can send me an email at axel.paris69@gmail.com.</p> Will you cover X in your guide? <p>I cannot guarantee that. What I can say is that I want to write about this list of topics in the near future: trees and ecosystem simulation, building, cities, and road generation, and clouds. No timeline though.</p>"},{"location":"#giving-feedback","title":"Giving feedback","text":"<p>As this guide has been mostly written by me, feedback is more than welcome. If you see something that could be explained better or is simply wrong, you can email me directly at axel.paris69@gmail.com.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#about","title":"About","text":""},{"location":"about/#code","title":"Code","text":"<p>All the code that involves the use of Three.js is under the MIT License, but the rest of this guide is released under either Public Domain or MIT license, whatever fits you best.</p>"},{"location":"about/#about-the-author","title":"About the Author","text":"<p>My name is Axel Paris and I am currently a Research Scientist at Adobe. I defended my PhD in Terrain Modeling and Generation in 2023. The concepts presented here were part of my daily life throughout the years, and I still use many today. If you to know more about me, you can go to my personal website.</p>"},{"location":"fundamentals/glossary/","title":"Glossary","text":""},{"location":"fundamentals/glossary/#dictionary","title":"Dictionary","text":"<p>TODO: definitions of all the technical terms used in the guide, alongside the chapter in which they are used.</p> <ul> <li>Elevation model</li> <li>Heightfield</li> <li>Volumetric model</li> <li>Voxel</li> <li>Implicit Surface</li> <li>Procedural noise</li> <li>Turbulence</li> <li>Interpolation</li> <li>Sphere tracing</li> <li>Erosion</li> <li>Geomorphology</li> <li>Karst</li> <li>Overhangs</li> <li>Construction tree</li> <li>3D Mesh</li> <li>River</li> <li>Geometric Skeleton</li> <li>Breaching</li> <li>Hydrology</li> <li>Warping</li> <li>Linear, Quadric, Cubic, Quartic</li> </ul>"},{"location":"fundamentals/implicits/","title":"Implicits","text":""},{"location":"fundamentals/implicits/#implicit-surfaces","title":"Implicit surfaces","text":"<p>TODO: what is an implicit surface, distinction between discrete and analytic. Briefly mention different models (blobs, SDFs at least), how they are used in CSG/Shape Modeling in general, and also in Machine Learning. Mention the 2D and 3D cases, and also maybe animated implicits? Mention shadertoy.</p>"},{"location":"fundamentals/interpolation/","title":"Interpolation","text":""},{"location":"fundamentals/interpolation/#interpolation","title":"Interpolation","text":"<p>Interpolation is a technique for creating a continuous function from a set of discrete samples with values. At the given samples, the function should return the already-known values; and elsewhere it should return something. Depending on the interpolation scheme, the resulting function may exhibit different level of smoothness and continuity. Interpolation is used everywhere in Computer Graphics, and is even used right now for rendering this web page.</p> <p>Note</p> <p>When I was learning this stuff, I regularly confused Interpolation with Approximation. When doing Approximation, we try to build a function that best approximate a set of discrete samples, without necessarily passing by the prescribed values. This includes, for instance, linear regression or the least squares approximation.</p> <p>There are too many interpolation schemes to explain them all, so we will focus here on the most commonly used: linear and cubic interpolation. More advanced references are available at the bottom of this page if you want to learn more.</p>"},{"location":"fundamentals/interpolation/#linear-interpolation","title":"Linear interpolation","text":"<p>Linear interpolation, also called lerp or mix, is a weighted average of two values. Let's look at one formula, which is the same in all dimensions:</p> \\[ lerp(a, b, t) = a + (b - a) * t \\] <p>Warning</p> <p>TODO: Write the equivalent in code here!</p> <p>The parameter \\(t\\) is called the interpolant, and represents how much we want to interpolation to have values close to \\(a\\) or \\(b\\). When \\(t=1\\), this is equal to \\(a + b - a\\) so the end value is \\(b\\). When \\(t=0\\), then \\((b -a)=0\\), so the end value is \\(a\\). When \\(t=0.5\\), the end value is an average of \\(a\\) and \\(b\\). </p> <p>Info</p> <p>If the interpolant \\(t\\) is outside of the \\([0, 1]\\) range, then we are doing linear extrapolation.</p> <p>We can try to look at linear interpolation in a geometric way: starting from a value \\(a\\), we go in the direction \\((b-a)\\) by a certain amount \\(t\\). This is illustrated on the figure below.</p>"},{"location":"fundamentals/interpolation/#floating-point-errors","title":"Floating-point errors","text":"<p>While perfectly valid from a mathematical point of view, it often results in floating-point imprecisions when implementing it on a computer. This is a very common difference between maths and code: in the end, our computations are done using a discrete number of bytes (float and double), which will often leads to precision issues. A more stable definition of linear interpolation is used:</p> \\[ lerp(a, b, t) = (1 - t) * a + t * b \\] <p>This is just a rewrite of the first equation that is strictly equivalent mathematically speaking, but more stable when implemented in code.</p> <p>Warning</p> <p>TODO: Write the equivalent in code here!</p>"},{"location":"fundamentals/interpolation/#bilinear-trilinear-interpolation","title":"Bilinear &amp; Trilinear interpolation","text":"<p>TODO: Explain that bilinear and trilinear are just lerps done multiple time in all directions. Show a figure with that + code.</p>"},{"location":"fundamentals/interpolation/#slerp-spherical-lerp","title":"Slerp: Spherical Lerp","text":"<p>TODO: Spherical linear interpolation, which interpolates between two points as if they were on the same circle arc. See figure below for visual differences. Put formula in here directly + code, and explain quickly when it is used.</p>"},{"location":"fundamentals/interpolation/#continuity-and-derivability","title":"Continuity and Derivability","text":"<p>TODO: \\(C^0\\) continuity only so there are no holes between our values, which is good, but means that there are discontinuities in the derivative at the sample locations. When we want better, we go with higher order interpolation scheme, such as quadratic or cubic explained below. Show the discontinuity in a figure.</p>"},{"location":"fundamentals/interpolation/#cubic-interpolation","title":"Cubic interpolation","text":"<p>TODO: Explain the more complex interpolation scheme, with code as well.</p>"},{"location":"fundamentals/interpolation/#exercices","title":"Exercices","text":"<p>TODO: find some ideas for an exercise.</p>"},{"location":"fundamentals/interpolation/#references","title":"References","text":""},{"location":"fundamentals/javascript/","title":"Javascript","text":""},{"location":"fundamentals/javascript/#javascript","title":"Javascript","text":""},{"location":"fundamentals/noise/","title":"Noise","text":""},{"location":"fundamentals/noise/#procedural-noise","title":"Procedural Noise","text":"<p>TODO: introduce what is noise, and give a brief overview of the different types, as well as references on nice libraries (FastNoise, things available in UE or Unity, etc...). Try to keep the overview 2D only for textures, do not mention terrains yet and stay general enough. Speak about higher dimensional noises as well.</p> <p>List of types that should be mentioned/shown:</p> <ul> <li>Perlin/Gradient</li> <li>Value</li> <li>Ridge</li> <li>Simplex</li> <li>Cellular</li> <li>Sparse Convolution</li> <li>Gabor</li> <li>Explain what is a Turbulence, a fractal sum as well.</li> </ul>"},{"location":"fundamentals/noise/#going-further","title":"Going Further","text":"<p>Exercise: </p> <ul> <li>What is the max of a Turbulence parameterized by a, f, o?</li> </ul>"},{"location":"terrain/intro/","title":"Introduction","text":""},{"location":"terrain/intro/#introduction","title":"Introduction","text":"<p>There are several ways to represent a terrain on a computer. This choice mainly depends on the target application (video games, scientific simulations), the type of landforms you want to represent (mountain ranges, caves, hills), and the scale at which you work. We first separate terrain representations in two: there are elevation models, and volumetric models. Elevation models are the most popular representation, as they provide a sufficiently accurate approximation while being compact in memory. However, they cannot represent volumetric landforms, such overhangs and arches, which are crucial scenic elements of virtual worlds. </p>"},{"location":"terrain/intro/#getting-started","title":"Getting started","text":"<p>In this guide, the main focus is on elevation models. The remainder of this page cover the basic of what is a heightfield, how to represent in memory, and render them on a computer. We will create the base classes and modules that will be used in the next sections. After that, the terrain section is organized in several subsections:</p> <ul> <li>\ud83c\udf0d Procedural, which covers everything you need to know on how to use noise functions and combine them to create beautiful terrains.</li> <li>\ud83c\udfd4\ufe0f Simulation, where you will learn algorithms inspired by real physics to simulate erosion.</li> <li>\ud83e\udea8 Volumetric, where we depart from elevation models and explain how to create underground caves, overhangs, and arches.</li> </ul> <p>Tip</p> <p>While these have been written to be read in order, it is also possible to just jump to a given section or completely skip one if you feel like it.</p>"},{"location":"terrain/intro/#heightfields","title":"Heightfields","text":"<p>Elevation models are also called planar models, or heightfields. Here we only represent the surface of the terrain and forget about the interior. As we will see, this is a powerful approximation particularly suited to terrains. More formally, a heightfield is defined by a mathematical function \\(h: \\mathbb{R}^2 \\rightarrow \\mathbb{R}\\) that computes the altitude (the z coordinate) of a point \\(\\mathbf{p}\\) in 2D space.</p> <p> </p> <p>If we were to write the equivalence between this mathematical function and Javascript code, it would look like this:</p> MathCode <p>\\(h(\\mathbf{p}) : \\mathbb{R}^2 \\rightarrow \\mathbb{R}\\)</p> <pre><code>/**\n* Elevation function for a heightfield.\n* p: 2D point with x and y members.\n*/\nfunction computeElevation(p) {\n    let h = ...;\n    return h;\n}\n</code></pre> <p>Now the remaining question is: how do we write the function \\(h\\), and its equivalent <code>computeElevation</code> in Javascript? There is no single answer but rather different options depending on what you need. The function \\(h\\) may be defined from a discrete set of samples or through procedural functions.</p>"},{"location":"terrain/intro/#discrete-vs-procedural","title":"Discrete vs Procedural","text":"<p>We consider that the only requirement for  \\(h\\) is that it must compute the altitude of any point in 2D space, which means that there is a common interface between discrete and procedural representations.</p> <p>Discrete representations are the most common for terrains. Elevation is computed as the interpolation of altitude values stored at discrete points, usually distributed on a regular grid. </p> <p>Note</p> <p>Discrete samples usually follow a regular grid pattern for lots of practical reasons, but samples may be distributed in other ways. For instance, it is perfectly valid to distribute samples according to a Delaunay triangulation. This won't be covered in this guide though.</p> <p> </p> <p>Discrete representations can be easily edited: we only need to modify the elevation stored at the discrete sample points. They are also popular because these samples may be initialized from real data. This type of heightfields is called a DEM (Digital Elevation Model), and represents rasterized terrain data from satellite images. </p> <p>The requirement for discrete heightfields is that the data must exist somewhere in memory. Depending on the resolution of the grid, this may become impractical. For instance, if we consider that altitudes are stored as 32-bits float (4 bytes), a full resolution \\(8k \\times 8k\\) terrain represents 256mo, which is already pretty large and does not even encompasses colors or other common attributes.</p> <p>Procedural representations are the complete opposite. Here, we do not explicitely store anything in memory but rely on a mathematical function to compute the elevation at a given point. This function may be constructed in multiples ways, but always indirectly through math and code, as opposed to manually editing a specific point as it is the case with discrete heightfields. </p> <p>The advantage is that you can theoritically represent infinitely detailed terrains without being limited by memory - you are only limited by the expressiveness of the underlying function. However, a typical downside of procedural models is that they require a lot more computations than discrete models, as the mathematical expression usually involves more operations than the interpolation of discrete samples.</p> <p>Tip</p> <p>The memory vs computation tradeoff is a typical one in Computer Graphics, and in Computer Sciences in general. There is no universal answer to which approach you should take. It all depends on your problem setting. It is important however to understand the pros and cons of both approaches.</p> <p>We will extensively cover how to create beautiful terrains using procedural functions in the next part of this guide. </p>"},{"location":"terrain/intro/#a-minimalist-implementation","title":"A Minimalist Implementation","text":"<p>Even though discrete and procedural models differ in many ways, there is a common interface to both that we can abstract to facilitate our work in the next sections. We will first create a <code>BaseHeightField</code> class that contains common functionalities and data.</p> <pre><code>class BaseHeightField {\n    // Public members\n    horizontalExtents = new Vector2(10, 10);\n    verticalExtents = new Vector2(0, 10);\n    bboxMin = new Vector2(-5, -5);\n    bboxMax = new Vector2(5, 5);\n\n    constructor(horizontalExtents, verticalExtents) {\n        this.horizontalExtents = horizontalExtents;\n        this.verticalExtents = verticalExtents;\n        this.bboxMin = new Vector2(\n            -this.horizontalExtents.x / 2.0,\n            -this.horizontalExtents.y / 2.0\n        );\n        this.bboxMax = new Vector2(\n            this.horizontalExtents.x / 2.0,\n            this.horizontalExtents.y / 2.0\n        );\n    }\n\n    // Compute altitude at a given 2D point\n    // This is where procedural and discrete differ\n    Elevation(p) {\n        [...]\n    }\n\n    /* \n    * Compute the position of a vertex from a virtual grid indices and resolution\n    * i, j: grid indicies\n    * nx, ny: grid dimensions\n    */\n    Vertex(i, j, nx, ny) {\n        let cellDiagonal = new Vector2(\n          this.horizontalExtents.x / (nx - 1),\n          this.horizontalExtents.y / (ny - 1),\n        );\n        let p = new Vector2(\n            this.bboxMin.x + i * cellDiagonal.x, \n            this.bboxMin.y + j * cellDiagonal.y\n        );\n        return new Vector3(\n            p.x,\n            p.y,\n            this.Elevation(p)\n        );\n    }\n}\n</code></pre> <p>Note</p> <p>This class contains redundant data, which is on purposes to speed-up computation and facilitate reading. This is not the most optimal.</p> <p>This way, we factorize some class members: not matter the representation, a heightfield has three dimensions (two horizontals, one vertical). Another interesting thing that we are able to put here is the <code>Vertex</code> function, which computes a position on the heightfield over a virtual grid characterized by its dimensions. This will be very handy in the next sections when we will create a mesh out of our heightfield.</p> <p>Tip</p> <p>An important thing to note is that we need the minimum and maximum elevation of the terrain. No matter the representation, we usually manipulate altitudes in some normalized form, thus the need to transform to world-space at the end of the computation.</p> <p>Of course, this class is not enough by itself. It is just an abstraction layer that we will now use for both discrete and procedural cases - as can be seen on the figure below.</p> <p> </p> <p>We still need additional data depending on what we choose. For discrete heightfields, we must first transform our world-space point \\(\\mathbf{p}\\) to the space in which our samples live (grid-space), and compute the interpolation between our samples. We will use bilinear interpolation in this example. On the other hand, for procedural heightfields, we need to write the mathematical function that computes the altitude. Here we will use a cosinus, which is of course in no way realistic but still works. </p> DiscreteProcedural <pre><code>// A minimalist discrete heightfield class\nclass DiscreteHeightField extends BaseHeightField {\n    // Size of the 2D data elevation array\n    nx = 256;\n    ny = 256;\n    data = null; // Altitude data\n\n    constructor(horizontalExtents, verticalExtents, nx, ny, data) {\n        super(horizontalExtents, verticalExtents);\n        this.nx = nx;\n        this.ny = ny;\n        this.data = data;\n    }\n\n    /**\n    * Bilinear interpolation of a set of values.\n    * a00, a10, a11, a01: values to interpolate.\n    * u, v: interpolation factors along x/y axis.\n    */\n    Bilinear(a00, a10, a11, a01, u, v) {\n        return (1 - u) * (1 - v) * a00 \n            + (1 - u) * (v) * a01 \n            + (u) * (1 - v) * a10 \n            + (u) * (v) * a11;\n    }\n\n    // Fetch the elevation data from grid indicies\n    SampleGrid(i, j) {\n        return this.data[i * this.ny + j] * this.verticalExtents.y;\n    }\n\n    // Compute the altitude of a 2D point using bilinear interpolation\n    Elevation(p) {\n        let d = new Vector2(\n            this.bboxMax.x - this.bboxMin.x,\n            this.bboxMax.y - this.bboxMin.y\n        );\n\n        let q = p.clone();\n        q.sub(this.bboxMin);\n\n        let u = q.x / d.x;\n        let v = q.y / d.y;\n\n        // Scale\n        u *= (this.nx - 1);\n        v *= (this.ny - 1);\n\n        // Integer coordinates\n        let i = Math.floor(u);\n        let j = Math.floor(v);\n\n        // Local coordinates within cell\n        u -= i;\n        v -= j;\n\n        return this.Bilinear(\n            this.SampleGrid(i, j), this.SampleGrid(i + 1, j), \n            this.SampleGrid(i + 1, j + 1), this.SampleGrid(i, j + 1), \n            u, v\n        );\n    }\n}\n</code></pre> <pre><code>// Minimalist procedural heightfield class\nclass ProceduralHeightField extends BaseHeightField {\n    constructor(horizontalExtents, verticalExtents) {\n        super(horizontalExtents, verticalExtents);\n    }\n\n    // Compute the altitude of a 2D point procedurally\n    Elevation(p) {\n        return Math.cos(p.x) + Math.cos(p.y);\n    }\n}\n</code></pre> <p>You probably noted that the discrete heightfield class is much longer than the procedural one. The difference is that the provided code works for any set of data stored on a regular grid, while the procedural function must be modified in its mathematical expression if you intend to modify the output, even slightly. </p>"},{"location":"terrain/intro/#rendering-a-heightfield","title":"Rendering a Heightfield","text":"<p>So far we mostly talk about the internal representation of a heightfield, let it be discrete or procedural. But since we are doing Computer Graphics, we need a way to render these heightfields on the screen. As always, we have multiple options for that. </p>"},{"location":"terrain/intro/#polygonization","title":"Polygonization","text":"<p>The classical way is to create a 3D mesh from the heightfield, and render it using traditional rasterization. Because we manipulate grid-based heightfield, it is straightforward to create a triangle mesh for it: each cell can be represented using four vertices and two triangles. You can think of this as a subdivided plane mesh. The code for this is the following:</p> <pre><code>/**\n* Basic 3D triangle mesh data structure.\n*/ \nclass Mesh {\n    vertices = null;\n    normals = null;\n    triangles = null;\n\n    constructor(vertices, normals, triangles) {\n        this.vertices = vertices;\n        this.normals = normals;\n        this.triangles = triangles;\n    }\n}\n\n/**\n* Create and return a 3D mesh representing a heightfield, with vertices, normals, and triangles.\n* hf: heightfield, which should provide a Vertex(x, y) function.\n* nx, ny: discretization of the desired mesh along x/y axes.\n*/\nCreateHeightFieldMesh(hf, nx, ny) {\n    var vertices = [];\n    var normals = [];\n    var triangles = [];\n\n    // Create vertices\n    for (var i = 0; i &lt; nx; i++) {\n        for (var j = 0; j &lt; ny; j++) {\n            vertices.push(hf.Vertex(i, j, nx, ny));\n            normals.push(new Vector3(0, 0, 0));\n        }\n    }\n\n    // Compute triangle indices\n    for (var i = 0; i &lt; nx - 1; i++) {\n        for (var j = 0; j &lt; ny - 1; j++) {\n            // Triangle 1\n            triangles.push(i * ny + j);\n            triangles.push((i + 1) * ny + j);\n            triangles.push((i + 1) * ny + j + 1);\n\n            // Triangle 2\n            triangles.push(i * ny + j);\n            triangles.push((i + 1) * ny + j + 1);\n            triangles.push(i * ny + j + 1);\n        }\n    }\n\n    // Compute normals from triangles\n    for (var i = 0; i &lt; triangles.length; i += 3) {\n        let a = vertices[triangles[i + 0]].clone();\n        let b = vertices[triangles[i + 1]].clone();\n        let c = vertices[triangles[i + 2]].clone();\n\n        let ba = b;\n        ba.sub(a);\n        let n = ba.cross(c.sub(a)).normalize();\n        normals[triangles[i + 0]].add(n);\n        normals[triangles[i + 1]].add(n);\n        normals[triangles[i + 2]].add(n);\n    }\n    for (var i = 0; i &lt; normals.length; i++) {\n        normals[i].normalize();\n    }\n\n    return new Mesh(vertices, normals, triangles);\n}\n</code></pre> <p>Tip</p> <p>Creating a mesh is possible for both discrete and procedural representations. The only requirement is that the heightfield should provide a function to compute the altitude of a 2D point. However, note that by discretizing a procedural heightfield, we loose the compact (procedural) memory aspect.</p> <p>Creating a triangle mesh has a memory cost: you need to explicitly store vertex, normal, and triangle data on the GPU. If your discretization parameter is high, the memory impact will also be high, which can be a limiting factor.</p> <p>Note</p> <p>Note that the resolution of our discrete heightfield has no connection with the resolution of our mesh: we can totally create a 1024x1024 mesh out of a 256x256 heightfield thanks to interpolation. </p>"},{"location":"terrain/intro/#sphere-tracing","title":"Sphere tracing","text":"<p>An alternative which shines best for procedural representations is to avoid the creation of a 3D mesh and render the terrain directly using raymarching or sphere tracing. While being theoritically elegant and simple to implement, this is however a little less adapted to current graphics and physics pipelines, which mainly work with triangle meshes. For a procedural heightfield, another downfall is that the rendering performance is directly tied to the complexity of the underlying function, which can quickly get really expensive.</p> <p>Note</p> <p>There are many ways to optimize the evaluation of a procedural function (for heightfields, or more generally implicit surfaces), including bounding volume hierarchies, expression simplification, and many others. The guide may be extended to include these in the (long-term) future.</p> <p>In this guide, we will mostly use the mesh representation and work with heightfields of relatively low resolution. When appropriate, a slider to modify the grid discretization will be exposed. If you want to learn more about sphere tracing terrains, you can take a look at shadertoy, which is full of great examples.</p>"},{"location":"terrain/intro/#interactive-example","title":"Interactive Example","text":"<p>All sections in this guide will be illustrated with figures and interactive examples thanks to Three.js. The one below uses the classes created in this page, and shows both discrete and procedural heightfields rendered as 3D meshes. The discrete version is initialized from a small DEM of the french alps. Move around the scene with the mouse!</p>"},{"location":"terrain/intro/#appendix-storing-heightfields-as-images","title":"Appendix: Storing Heightfields as Images","text":"<p>A typical way of storing heightfield data on a disk is to use images, which makes complete sense because we store a single elevation value for each grid sample. You can find many examples of this online, as DEMs are typically shared as PNG files. However, an image only provides incomplete information about a terrain: there is no way to know the world space extent nor the altitude range. It is thus not unusual to see online posts with terrains exaggerated vertically or horizontally. This is a good reminder that terrains are not images.</p> <p> Example of images representing terrains, with no way of telling what is the actual horizontal and vertical extents. Left is a DEM of the Alps with a 12km horizontal extent, and a altitude range of [205, 4805] meters. Right is a procedural ridge noise baked with no real world-space dimensions. </p> <p>There is no real solution to this problem, except that you should provide additional information alongside the image file of your heightfield. Image files are still vastly used because they are easy to share and can be opened and edited using various softwares. </p>"},{"location":"terrain/intro/#appendix-going-further","title":"Appendix: Going further","text":"<p>Other models for representing heightfields were developed throughout the years - for the discrete case we covered regular heightfields, which are the most popular representation, but there are others that I did not cover:</p> <ul> <li>Hexagon and triangular fields [Dixon et al. 1994]</li> <li>Combinatorial maps [Crespin et al. 2014]</li> </ul>"},{"location":"terrain/intro/#associated-files","title":"Associated files","text":"<p>Files associated with this page are available here.</p>"},{"location":"terrain/procedural/craters_cliffs_and_more/","title":"Craters cliffs and more","text":""},{"location":"terrain/procedural/craters_cliffs_and_more/#craters-cliffs-and-more","title":"Craters, cliffs, and More!","text":"<p>TODO: show how to design more primitives: craters, cliffs. Introduce other skeleton function than point? </p>"},{"location":"terrain/procedural/noise_for_terrains/","title":"Noise for terrains","text":""},{"location":"terrain/procedural/noise_for_terrains/#using-noise-for-terrain-generation","title":"Using Noise for Terrain Generation","text":"<p>Noise is a powerful tool that has been applied in many (if not all) subdomains of Computer Graphics. Terrain generation is no exception. In fact, using noise to generate mountains was one of the first application, going back as far as the late eighties with the seminal work of Kenton Musgrave. </p> <p>For terrains, the core idea is to use the scalar value returned by the noise as the altitude at a given point. You can think of this as a world-space plane, with the elevation of points defined by the noise function. Below is an example of the same noise rendered on a 2D texture and on a 3D displaced plane.</p> <p> </p> <p>Now let's see how to do that in practice. Our goal is to define the procedural elevation function \\(h\\) using some noise function \\(n\\). Recall that \\(h\\) takes as input a 2D point in input and return the elevation, or put otherwise it is defined as \\(h(\\mathbf{p}) : \\mathbb{R}^2 \\rightarrow \\mathbb{R}\\).</p> <p>Note</p> <p>If you want to dig into the details of how noise functions work internally, please refer to this page.</p>"},{"location":"terrain/procedural/noise_for_terrains/#our-first-noise-based-terrain","title":"Our first noise-based terrain","text":"<p>Noise functions are simply dependent on the position at which they are evaluated - they thus belong to the category of procedural functions. They require only very few data to be stored and rely on a procedure to compute a scalar value. If we extend our ProceduralHeightField class introduced in the previous part, we may define the elevation function \\(h\\) again using our Perlin noise:</p> <pre><code>class ProceduralHeightField extends BaseHeightField {\n    constructor(horizontalExtents, verticalExtents) {\n        super(horizontalExtents, verticalExtents);\n    }\n\n    // Compute the altitude of a 2D point procedurally using Perlin noise\n    Elevation(p) {\n        return amplitude * perlin.noise(x * freq, y * freq, 0.0);\n    }\n}\n</code></pre> <p>This gives us the following result. Use the mouse to turn around it, and play with the frequency and amplitude!</p> <p>Notice the impact of amplitude which vertically stretch the terrain, and frequency which changes the horizontal scales of the bumps. These two values are just a way to modify the output of our function according to our needs. </p> <p>Tip</p> <p>For the noise algorithm, we rely on Three.js Perlin noise implementation, which was itself used to showcase a procedural terrain here with the code here.</p> <p>Another common control not showcased here is the number of successive octaves, which is used for doing sum of perlin noise, also called a fractal noise. If we were to write the equivalent formula and code for a fractal sum of noise, it would look like this:</p> MathCode <p>\\(h(\\mathbf{p}) = \\sum_{i=0}^{o} a_i n (\\mathbf{p} f_i)\\)</p> <p>\\(a_i = a_0 / 2i\\)</p> <p>\\(f_i = f_0~2i\\)</p> <pre><code>/**\n* Fractal sum of perlin noise.\n* p: 2D point with x and y members.\n* a0 is the amplitude of the first octave.\n* f0 is the frequency of the first octave.\n*/\nfunction computeElevation(p) {\n    var ret = 0.0;\n    var a = a0;\n    var f = f0;\n    for (var i = 0; i &lt; o; i++) {\n        ret += a * perlin.noise(p.x * f, p.y * f, 0.0);\n        a *= 0.5;\n        f *= 2.0;\n    }\n    return ret;\n}\n</code></pre> <p>With \\(a_0\\) the base amplitude, \\(f_0\\) the base frequency. Notice how at the same time, we increase the frequency of successive octaves, and decrease their respective amplitude. This function is also commonly referred to as a turbulence, or fractional brownian motion (fBm for short). Put simply, it is a sum of noise values.</p> <p>Info</p> <p>The multipliers for the amplitude and frequency are respectively called the lacunarity and persistence. You may slightly change their values and create terrains with slightly different looks. This is left as an exercise to the reader.</p> <p>At this point you may not really believe that using noise can help creating realistic terrains. You can play around with the amplitude, frequency and will probably improve the results. However, noise-based terrains still have several limitations. </p>"},{"location":"terrain/procedural/noise_for_terrains/#the-issues-of-noise","title":"The issues of Noise","text":"<p>Creating terrains using fractal noise has been done extensively in video games for multiple decades. While you can definitely get a mountainous look for your terrain, getting a proper valley for instance might be more difficult, or even impossible if you limit yourself to simple, uniform fractal noise. We could list some of the limitations of the above example, including:</p> <ul> <li> <p>No valleys: you either get a very mountainous terrain or a very flat terrain, but having a mix of both is difficult.</p> </li> <li> <p>You may notice the same pattern is everywhere. This is one interesting property of noise function: self-similarity. In our case, it's also a limitation.</p> </li> <li> <p>Similarly to vallyes, mountains lacks the ridge structure typically found in real mountain ranges. They are just really isolated peaks here.</p> </li> </ul> <p>In the end, it seems that noise is only capable of generating small bumps. Can we alleviate this issue somehow?</p>"},{"location":"terrain/procedural/noise_for_terrains/#multifractals-to-the-rescue","title":"Multifractals to the rescue?","text":"<p>Some of these problems can be partially solved by using a more advanced technique called a multifractal noise. The core idea is to modulate the amplitude \\(a\\) of successive octave based on the noise value of previous iterations. This way areas with a low amplitude at iteration \\(k\\) will get a noise value of lower amplitude at iteration \\(k+1\\), and the opposite will happen for mountainous areas. </p> <p>Let \\(t_k\\) denote the fractal noise at iteration \\(k\\), this gives us the following maths and code:</p> MathCode <p>\\(t_{k+1}(\\mathbf{p}) = t_k(\\mathbf{p}) + \\alpha(t_k(\\mathbf{p}))~a_{k+1}~n(\\mathbf{p}f_i) \\qquad t_0(\\mathbf{p}) = a_0~n(\\mathbf{p}f_i)\\)</p> <pre><code>/**\n* Weight function for multifractal perlin noise.\n* t accumulated turbulence value so far.\n* o current iteration number\n*/\nfunction alpha(t, o) {\n  if (o == 0) {\n    return 1.0;\n  }\n  let frequency = 1.0;\n  let H = 0.75;\n  for (let i = 0; i &lt; o; i++) {\n    frequency *= 2.0;\n  }\n  return t * Math.pow(frequency, -H);\n}\n\n/**\n* Multifractal perlin noise.\n* p: 2D point with x and y members.\n* a0 is the amplitude of the first octave.\n* f0 is the frequency of the first octave.\n*/\nfunction computeElevation(x, y) {\n  var ret = 0.0;\n  var f = f0;\n  for (var i = 0; i &lt; o; i++) {\n    ret += alpha(ret, i) * perlin.noise(x * f, y * f, 0.0);\n    f *= 2.0;\n  }\n  return a0 * ret;\n}\n</code></pre> <p>The function \\(\\alpha : \\mathbb{R} \\rightarrow \\mathbb{R}\\) computes the weight of the next octave \\(k\\) based on the total accumulated value so far \\(t_k\\).</p> <p>Below is an example that shows different types of noise for generating terrain shapes, including classical perlin and ridge noise, as well as their multifractal variants. Play around with the different settings to get a feel of how noise behaves.</p> <p>Multifractals do not solve everything. However, the idea of using procedural functions to generate shapes is interesting and can be pushed further: what if we could create specific functions to represent dunes, cliffs, mountains, mountain ridges, rivers, and more?  This is the subject of the next chapters, where we will design a library of procedural terrain shapes and combine them together to create more visually interesting and varied terrains.</p>"},{"location":"terrain/procedural/noise_for_terrains/#going-further","title":"Going further","text":"<p>You may try to use other kinds of noise to create terrains, for instance Worley (or cellular) noise, its fractal variants, Billowy noise, or try to model different effects such as domain warp. </p>"},{"location":"terrain/procedural/noise_for_terrains/#associated-files","title":"Associated files","text":"<p>Files associated with this page are available here.</p>"},{"location":"terrain/procedural/our_first_primitive/","title":"Our first primitive","text":""},{"location":"terrain/procedural/our_first_primitive/#creating-our-first-terrain-primitive","title":"Creating our First Terrain Primitive","text":"<p>Simply using uniform fractal or multifractal noise is not enough for creating realistic terrains: we simply lack the variety found in real terrains. The compact procedural aspect of noise functions remains interesting - we are however limited by our ability to design a function that represents the desired landforms. In this part we will see how to design such shapes only using basic mathematical tools.</p> <p>The core idea of this chapter is that procedural heightfields are not limited to noise: we can use other functions, such as trigonometric functions (cos, sin, tan) as well as geometric skeletons (explained in a bit). You may think of all of these as 1D or 2D functions of different shapes that we will combine together using simple operators such as addition and multiplication, to achieve a desired appearance. In concrete terms, we will design terrain primitives, and later combine them together to create a large-scale terrain.</p> <p>This may still be a little abstract - Let's take an example: How about creating sand dunes? \ud83c\udfdc\ufe0f</p>"},{"location":"terrain/procedural/our_first_primitive/#designing-transverse-dunes","title":"Designing Transverse Dunes","text":"<p>Sand dunes are a very good and educational example when it comes to creating terrain primitives. For those not familiar with how sand dunes look like, the figure below recaps the most common shapes identified by geomorphologists.</p> <p> </p> <p>Sand dunes emerge from the interplay between wind of variable strength and direction over time, sand, and bare bedrock underneath. Here we focus on transverse dunes, which exhibit regular longitudinal patterns orthogonal to the wind direction. </p> <p>The first observation is that the pattern is repeating over space at mostly regular intervals; the second observation is that the atomic repeating element is almost a straight line. If we take a side-view perspective, these dunes almost look like... a cosinus function. This is actually the only thing that we need to model such shape: we can use a 1D cosinus as our procedural heightfield function \\(h\\), taking as parameter the \\(x\\) or \\(y\\) coordinate of the point \\(\\mathbf{p}\\):</p> MathCode <p>\\(h(\\mathbf{p}) : \\cos(\\mathbf{p}_x)\\)</p> <pre><code>function computeElevation(p) {\n    return Math.cos(p.x);\n}\n</code></pre> <p>Put in 3D, it looks like this.</p> <p> </p> <p>This is already quite good, although a bit 'hilly'. We are missing the sharp aspect of crests at the top of the dunes. This can done basically inverting the shape of our cosinus using an absolute value:</p> MathCode <p>\\(h(\\mathbf{p}) : 1 - | \\cos(\\mathbf{p}_x) |\\)</p> <pre><code>function computeElevation(p) {\n    return 1 - Math.abs(Math.cos(p.x));\n}\n</code></pre> <p>Which leads to the following 3D result. Notice how we managed to create sharp features using a simple absolute value. This trick is similar to the one used to create ridge noise.</p> <p> </p> <p>This is already pretty satisfying, can we do better? The result is still lacking some irregularities: nothing is as straight and as regular in real life. Noise is a great tool for such task: it is increadibly useful to add variety and details on terrain primitives. There are several ways to do this: for instance a small layer of noise may be added at the top or bottom of the dunes, or a warp the input position may be used to to add irregularities to the crest directions. You may refer to the interactive example below to compare the different versions with various additional parameters.</p> <p>For the rest, the only limitation is your imagination and your ability to picture the combination of different mathematical functions. It's fun to do but still require a bit of practice.</p> <p>Tip</p> <p>It is sometimes easier to visualize and design shapes in 1D rather than 2D or 3D: for that, Desmos is a great tool that I use regularly. Shadertoy is also a great source of inspiration.</p>"},{"location":"terrain/procedural/our_first_primitive/#designing-a-single-mountain","title":"Designing a Single Mountain","text":"<p>Our sand dunes look relatively good. Now let's see how we can create a single mountain primitive. We don't want to create a mountain range here, just a single one that we can then combine with our dunes. How can we do that?</p> <p>Maybe your first idea is to reuse the cosine function introduced before - except that here, we are not interested in the periodic aspect, so this might be a little less adapted. What we need is a punctual function that, given a location in the scene, will create the shape of a mountain. We are going to use what is often called a geometric skeleton.</p>"},{"location":"terrain/procedural/our_first_primitive/#point-primitive","title":"Point Primitive","text":"<p>Let's start by using a Perlin Noise with a rather high amplitude everywhere, as seen in the previous part. This looks rather awful because there are peaks everywhere, while we just want a single one.</p> <p>Geometric skeletons are control primitives: they are used to define where a given function should be active or inactive. Let's imagine the simplest skeleton, that has a value of 1 in a circle located at the origin (0, 0) of the scene, with radius 2. We combine our noise value \\(n\\) with the value returned by the skeleton \\(s\\).</p> MathCode <p>\\(h(\\mathbf{p}) : s(\\mathbf{p}) \\cdot n(\\mathbf{p})\\)</p> <pre><code>function skeleton(x, y) {\n    let d = x * x + y * y; // distance to origin\n    if (d &lt; 3.0)\n        return 1.0;\n    else\n        return 0.0;\n}\n\nfunction mountainPrimitive(x, y) {\n    let n = fBm(x, y);  // noise\n    let s = skeleton(x, y); // skeleton\n    return n * s; // combination of the two. \n} \n</code></pre> <p>We have successfully restricted the noise to a subpart of space. Notice how the radius controls the size of the skeleton. This still looks a bit off the function \\(s\\) is not continuous: it just takes values of 0 or 1. We can improve that by using the distance from the point \\((x, y)\\) to the origin, and dividing by the radius, like this:</p> <pre><code>function skeleton(x, y) {\n    let d = x * x + y * y; // distance to origin\n    if (d &gt; stateGUI.Radius)\n        return 0.0;\n    else\n        return 1 - (d / stateGUI.Radius);\n}\n\nfunction mountainPrimitive(x, y) {\n    let n = fBm(x, y);  // noise\n    let s = skeleton(x, y); // skeleton\n    return n * s; // combination of the two. \n} \n</code></pre> <p>Notice how the surface has a nice, smooth transition between the mountain and the flat ground. There are other geometric skeleton that we will use in the next parts, but the point primitive is already enough for us to design a desert scene with dunes and mountains.</p>"},{"location":"terrain/procedural/our_first_primitive/#putting-it-all-together","title":"Putting it all together","text":"<p>We start with our transverse dune primitive from the previous section, and add the mountain primitive: <pre><code>function dunePrimitive(x, y) {\n    let n = fBm(x, y); \n    return 1 - Math.abs(Math.cos(p.x + n));\n}\n\nfunction mountainPrimitive(x, y) {\n    let n = fBm(x, y);\n    let s = skeleton(x, y);\n    return n * s; \n}\n\nfunction computeElevation(x, y) {\n    let h1 = dunePrimitive(x, y);\n    let h2 = mountainPrimitive(x, y);\n    return h1 + h2;\n}\n</code></pre></p> <p>And that's it: here is our first terrain with two different procedural functions, one for each landforms. Here we choose to add both elevations, but we will see other ways of combining different primitives together in the next chapters.</p>"},{"location":"terrain/procedural/our_first_primitive/#going-further","title":"Going further","text":"<p>You may try to change the noise function: usually, ridge noise gives a more realistic vibe for mountains. You may also try to select which parts of the noise you want for your mountain While noise functions are self-similar, you may still need to select the parts with high positive amplitudes. This can be achieved by translating the input point \\((x, y)\\) by some arbitrary offset.</p>"},{"location":"terrain/procedural/our_first_primitive/#associated-files","title":"Associated files","text":"<p>Files associated with this page are available here.</p>"},{"location":"terrain/procedural/river_primitives/","title":"River primitives","text":""},{"location":"terrain/procedural/river_primitives/#curve-based-primitives","title":"Curve-based Primitives","text":""},{"location":"terrain/procedural/river_primitives/#distance-to-a-curve","title":"Distance to a curve","text":""},{"location":"terrain/procedural/river_primitives/#quadric-curve","title":"Quadric curve","text":""},{"location":"terrain/procedural/river_primitives/#cubic-curve","title":"Cubic curve","text":""},{"location":"terrain/procedural/river_primitives/#putting-that-on-a-terrain-rivers-roads-canyons","title":"Putting that on a terrain: rivers, roads, canyons","text":""},{"location":"terrain/procedural/river_primitives/#going-further","title":"Going further","text":""},{"location":"terrain/procedural/terrain_construction_tree/","title":"Terrain construction tree","text":""},{"location":"terrain/procedural/terrain_construction_tree/#terrain-construction-trees","title":"Terrain Construction Trees","text":"<p>TODO: introduce the more formal notion of construction tree, or graph of primitive and operators. This is very classical paradigm in procedural modeling, and in computer graphics in general. These structures have interesting properties, their queries can be optimized, and they can be extended with as many primitives and operators that you may design.</p>"},{"location":"terrain/procedural/terrain_construction_tree/#going-further","title":"Going Further","text":"<ul> <li>Cite JD thesis as a reference (in french though), and the associated article.</li> <li>Cite multi-material extensions with other trees to represent vegetation or water for instance.</li> </ul>"},{"location":"terrain/simulation/simulation_intro/","title":"Introduction","text":""},{"location":"terrain/volumetric/going_3D/","title":"What is a Volumetric Terrain?","text":""},{"location":"terrain/volumetric/implicits/","title":"Using Implicit Surfaces","text":""},{"location":"terrain/volumetric/voxels/","title":"Using Voxels","text":""}]}