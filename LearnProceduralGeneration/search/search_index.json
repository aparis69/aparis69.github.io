{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the Procedural Generation guide. This is aimed at people that want to learn more about world generation, featuring terrain, ecosystem simulation, river animation, just to name a few. On top of being as accessible as possible to everyone, the goal here is to provide explanations, mathematical formulas, clear code, demos, and exercises for all examples. </p> <p>Interactive demos are made possible thanks to the great Three.js library. Only basic knowledge in Computer Graphics should be required to go through this guide.</p> <p>Warning</p> <p>This guide is currently (as of 2024) being written and is thus a work in progress. Except significant changes, errors, and new content being added. Feedback is welcome.</p> <p>Note</p> <p>Todolist:</p> <ul> <li>Add a screenshot of all the interactive examples on this page. This should be as colorful as possible.</li> <li>Find some good default parameters for each example. Visuals must be great at first glance.</li> <li>Each page should have at least one interactive example to play with.</li> <li>It should be easy to modify the example, maybe directly in the page? Or by clicking on a button that opens a setup JS playground?</li> <li>At the beginning (or end?) of each page, do a 'Summary' or 'Takeaways' of the main points.</li> </ul>"},{"location":"#what-is-procedural-generation","title":"What is Procedural Generation?","text":"<p>Procedural Generation refers to a way of creating digital content, let it be 3D models, textures, patterns, colors, and so on. The idea is that data is generated more or less  automatically through the use of an algorithm or a procedure, rather than created manually. Generating content procedurally can provide many advantages, including scalability (with the ability to generate a large set of different shapes), memory efficiency (by only storing the generation procedure, and not its output), and a lot more. Procedural generation is a powerful tool that artists use in their day to day life.</p> <p>Computer Graphics has been a great playground for Procedural Generation throughout the years, with the first papers going back to 1990 with Frank Ebert.</p> <p>Note that there is not a single definition for these terms. This is just my personal one and the one that will be used throughout this guide.</p>"},{"location":"#do-i-need-to-know-math","title":"Do I need to know Math?","text":"<p>Only a very basic knowledge of linear algebra and math is expected. When possible, I provide the equivalence between math and code so that it is accessible to more people. For vector and matrice types, we will extensively use the strutures provided by Three.js, such as Vector2,   Vector3, and Matrix4.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>This guide is separated in multiple parts, each one covering a different aspect of world generation. These are mostly independent and can be read in any order. All sections are illustrated with interactive examples that run directly in your web browser. Small exercises are mentioned at the end of each page, if you want to go deeper into a given topic.</p> <ul> <li>\ud83d\udcda Fundamentals, which covers some basics that help you understand the next parts. You can skip this section, or just go back to it from time to time if you don't understand some concept. It also contains a glossary of all the technical terms used throughout the guide.   </li> <li>\u26f0\ufe0f Terrain, where you will about the different techniques for generating terrains, including procedural noise and erosion simulation.</li> <li>\ud83c\udf0a Rivers, with everything you need to know to generate realistic river trajectories as well as animated water surfaces.</li> <li>More to come!</li> </ul> <p>The concepts presented in this guide are not new groundbreaking research. Everything has either been published in research papers, used in multiple video games, or written and explained in various blogs. The end goal of this guide is to be as complete as possible and become a go-to reference for Procedural World Generation.</p>"},{"location":"#faq","title":"FAQ","text":"Why another Procedural Generation guide? <p>There are a lot of great resources online to get started - but none of them was interactive and accessible enough for my tastes. </p> Can I use the code written here? <p>The code that uses Three.js is under MIT License - and the rest, written by me, is released under MIT unless specified otherwise.</p> Why Javascript and not C++? <p>It is true that Computer Graphics topics in general are usually explained in C++, but I wanted this guide to be as interactive as possible, which is easier in Javascript (although I am not a fan nor an expert of this language).</p> I saw an error/a typo. Where can I report it? <p>You can send me an email at axel.paris69@gmail.com.</p> Will you cover X in your guide? <p>I cannot guarantee that. What I can say is that I want to write about this list of topics in the near future: trees and ecosystem simulation, building, cities, and road generation, and clouds. No timeline though.</p>"},{"location":"#giving-feedback","title":"Giving feedback","text":"<p>As this guide has been mostly written by a single person, feedback is more than welcome. If you see something that could be explained better or is simply wrong, you can email me directly at axel.paris69@gmail.com.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#about","title":"About","text":""},{"location":"about/#code","title":"Code","text":"<p>All the code that involves the use of Three.js is under the MIT License, but the rest of this guide is released under either Public Domain or MIT license, whatever fits you best.</p>"},{"location":"about/#about-the-author","title":"About the Author","text":"<p>My name is Axel Paris and I am currently a Research Scientist at Adobe. I defended my PhD in Terrain Modeling and Generation in 2023. The concepts presented here were part of my daily life throughout the years, and I still use many today. If you to know more about me, you can go to my personal website.</p>"},{"location":"about/#references","title":"References","text":"<p>Below is a non-exhaustive lists of resources used to write this blog, along with some explanations. There are many gems in there, so feel free to explore, and also report dead links to me at axel.paris69@gmail.com.</p>"},{"location":"fundamentals/glossary/","title":"Glossary","text":""},{"location":"fundamentals/glossary/#dictionary","title":"Dictionary","text":"<p>TODO: definitions of all the technical terms used in the guide, alongside the chapter in which they are used.</p> <ul> <li>Elevation model</li> <li>Heightfield</li> <li>Volumetric model</li> <li>Voxel</li> <li>Implicit Surface</li> <li>Procedural noise</li> <li>Turbulence</li> <li>Interpolation</li> <li>Sphere tracing</li> <li>Erosion</li> <li>Geomorphology</li> <li>Karst</li> <li>Overhangs</li> <li>Construction tree</li> <li>3D Mesh</li> <li>River</li> <li>Geometric Skeleton</li> <li>Breaching</li> <li>Hydrology</li> <li>Warping</li> <li>Linear, Quadric, Cubic, Quartic</li> </ul>"},{"location":"fundamentals/implicits/","title":"Implicits","text":""},{"location":"fundamentals/implicits/#implicit-surfaces","title":"Implicit surfaces","text":"<p>TODO: what is an implicit surface, distinction between discrete and analytic. Briefly mention different models (blobs, SDFs at least), how they are used in CSG/Shape Modeling in general, and also in Machine Learning. Mention the 2D and 3D cases, and also maybe animated implicits? Mention shadertoy.</p>"},{"location":"fundamentals/interpolation/","title":"Interpolation","text":""},{"location":"fundamentals/interpolation/#interpolating-data","title":"Interpolating Data","text":"<p>Bilinear interpolation, bi-cubic interpolation.</p>"},{"location":"fundamentals/noise/","title":"Noise","text":""},{"location":"fundamentals/noise/#procedural-noise","title":"Procedural Noise","text":"<p>TODO: introduce what is noise, and give a brief overview of the different types, as well as references on nice libraries (FastNoise, things available in UE or Unity, etc...). Try to keep the overview 2D only for textures, do not mention terrains yet and stay general enough. Speak about higher dimensional noises as well.</p> <p>List of types that should be mentioned/shown:</p> <ul> <li>Perlin/Gradient</li> <li>Value</li> <li>Ridge</li> <li>Simplex</li> <li>Cellular</li> <li>Sparse Convolution</li> <li>Gabor</li> <li>Explain what is a Turbulence, a fractal sum as well.</li> </ul>"},{"location":"fundamentals/noise/#going-further","title":"Going Further","text":"<p>Exercise: </p> <ul> <li>What is the max of a Turbulence parameterized by a, f, o?</li> </ul>"},{"location":"rivers/hydrology_correction/","title":"The Importance of Breaching","text":""},{"location":"rivers/hydrology_correction/#going-further","title":"Going Further","text":""},{"location":"rivers/intro/","title":"Introduction","text":""},{"location":"rivers/intro/#what-is-not-covered-here","title":"What is not covered here","text":""},{"location":"rivers/river_generation/","title":"Generating River Networks","text":""},{"location":"rivers/river_generation/#going-further","title":"Going Further","text":""},{"location":"terrain/intro/","title":"Introduction","text":""},{"location":"terrain/intro/#introduction","title":"Introduction","text":"<p>There are several ways to represent a terrain on a computer. This choice mainly depends on the target application (video games, scientific simulations), the type of landforms you want to represent (mountain ranges, caves, hills), and the scale at which you work. We first separate terrain representations in two: there are elevation models, and volumetric models. Elevation models are the most popular representation, as they provide a sufficiently accurate approximation while being compact in memory. However, they cannot represent volumetric landforms, such overhangs and arches, which are crucial scenic elements of virtual worlds. </p>"},{"location":"terrain/intro/#getting-started","title":"Getting started","text":"<p>In this guide, the main focus is on elevation models. The remainder of this page cover the basic of what is a heightfield, how to represent in memory, and render them on a computer. We will create the base classes and modules that will be used in the next sections. After that, the terrain section is organized in several subsections:</p> <ul> <li>\ud83c\udf0d Procedural, which covers everything you need to know on how to use noise functions and combine them to create beautiful terrains.</li> <li>\ud83c\udfd4\ufe0f Simulation, where you will learn about physically-based algorithms that simulates erosion on a given terrain to increase realism.</li> <li>\ud83e\udea8 Volumetric, where we depart from elevation models and explain how to create underground caves, overhangs, and arches.</li> </ul> <p>Tip</p> <p>While these have been written to be read in order, you may also jump to a given section, or completely skip some if you feel like it.</p>"},{"location":"terrain/intro/#heightfields","title":"Heightfields","text":"<p>Elevation models are also called planar models, or heightfields. Here we only represent the surface of the terrain and forget about the interior. As we will see, this is a powerful approximation particularly suited to terrains. More formally, a heightfield is defined by a mathematical function \\(h: \\mathbb{R}^2 \\rightarrow \\mathbb{R}\\) that computes the altitude (the z coordinate) of a point \\(\\mathbf{p}\\) in 2D space.</p> <p> </p> <p>If we were to write the equivalence between this mathematical function and Javascript code, it would look like this:</p> MathCode <p>\\(h(\\mathbf{p}) : \\mathbb{R}^2 \\rightarrow \\mathbb{R}\\)</p> <pre><code>/**\n* Elevation function for a heightfield.\n* p: 2D point with x and y members.\n*/\nfunction computeElevation(p) {\n    let h = ...;\n    return h;\n}\n</code></pre> <p>Now the remaining question is: how do we write the function \\(h\\), and its equivalent <code>computeElevation</code> in Javascript? There is no single answer but rather different options depending on what you need. The function \\(h\\) may be defined from a discrete set of samples or through procedural functions.</p>"},{"location":"terrain/intro/#discrete-vs-procedural","title":"Discrete vs Procedural","text":"<p>We consider that the only requirement for  \\(h\\) is that it must compute the altitude of any point in 2D space, which means that there is a common interface between discrete and procedural representations.</p> <p>Discrete representations are the most common for terrains. Elevation is computed as the interpolation of altitude values stored at discrete points, usually distributed on a regular grid. </p> <p>Note</p> <p>Discrete samples usually follow a regular grid pattern for lots of practical reasons, but samples may be distributed in other ways. For instance, it is perfectly valid to distribute samples according to a Delaunay triangulation. This won't be covered in this guide though.</p> <p> </p> <p>Discrete representations can be easily edited: we only need to modify the elevation stored at the discrete sample points. They are also popular because these samples may be initialized from real data. This type of heightfields is called a DEM (Digital Elevation Model), and represents rasterized terrain data from satellite images. </p> <p>The requirement for discrete heightfields is that the data must exist somewhere in memory. Depending on the resolution of the grid, this may become impractical. For instance, if we consider that altitudes are stored as 32-bits float (4 bytes), a full resolution \\(8k \\times 8k\\) terrain represents 256mo, which is already pretty large and does not even encompasses colors or other common attributes.</p> <p>Procedural representations are the complete opposite. Here, we do not explicitely store anything in memory but rely on a mathematical function to compute the elevation at a given point. This function may be constructed in multiples ways, but always indirectly through math and code, as opposed to manually editing a specific point as it is the case with discrete heightfields. </p> <p>The advantage is that you can theoritically represent infinitely detailed terrains without being limited by memory - you are only limited by the expressiveness of the underlying function. However, a typical downside of procedural models is that they require a lot more computations than discrete models, as the mathematical expression usually involves more operations than the interpolation of discrete samples.</p> <p>Tip</p> <p>The memory vs computation tradeoff is a typical one in Computer Graphics, and in Computer Sciences in general. There is no universal answer to which approach you should take. It all depends on your problem setting. But it is important to understand the pros and cons of both approaches.</p> <p>We will extensively cover how to create beautiful terrains using procedural functions in the next part of this guide. </p>"},{"location":"terrain/intro/#a-minimalist-implementation","title":"A Minimalist Implementation","text":"<p>Even though discrete and procedural models differ in many ways, there is a common interface to both that we can abstract to facilitate our work in the next sections. We will first create a <code>BaseHeightField</code> class that contains common functionalities and data.</p> <pre><code>class BaseHeightField {\n    // Public members\n    horizontalExtents = new Vector2(10, 10);\n    verticalExtents = new Vector2(0, 10);\n    bboxMin = new Vector2(-5, -5);\n    bboxMax = new Vector2(5, 5);\n\n    constructor(horizontalExtents, verticalExtents) {\n        this.horizontalExtents = horizontalExtents;\n        this.verticalExtents = verticalExtents;\n        this.bboxMin = new Vector2(\n            -this.horizontalExtents.x / 2.0,\n            -this.horizontalExtents.y / 2.0\n        );\n        this.bboxMax = new Vector2(\n            this.horizontalExtents.x / 2.0,\n            this.horizontalExtents.y / 2.0\n        );\n    }\n\n    // Compute altitude at a given 2D point\n    // This is where procedural and discrete differ\n    Elevation(p) {\n        [...]\n    }\n\n    /* \n    * Compute the position of a vertex from a virtual grid indices and resolution\n    * i, j: grid indicies\n    * nx, ny: grid dimensions\n    */\n    Vertex(i, j, nx, ny) {\n        let cellDiagonal = new Vector2(\n          this.horizontalExtents.x / (nx - 1),\n          this.horizontalExtents.y / (ny - 1),\n        );\n        let p = new Vector2(\n            this.bboxMin.x + i * cellDiagonal.x, \n            this.bboxMin.y + j * cellDiagonal.y\n        );\n        return new Vector3(\n            p.x,\n            p.y,\n            this.Elevation(p)\n        );\n    }\n}\n</code></pre> <p>Note</p> <p>This class contains redundant data, which is on purposes to speed-up computation and facilitate reading. This is not the most optimal.</p> <p>This way, we factorize some class members: not matter the representation, a heightfield has three dimensions (two horizontals, one vertical). Another interesting thing that we are able to put here is the <code>Vertex</code> function, which computes a position on the heightfield over a virtual grid characterized by its dimensions. This will be very handy in the next sections when we will create a mesh out of our heightfield.</p> <p>Tip</p> <p>An important thing to note is that we need the minimum and maximum elevation of the terrain. No matter the representation, we usually manipulate altitudes in some normalized form, thus the need to transform to world-space at the end of the computation.</p> <p>Of course, this class is not enough by itself. It is just an abstraction layer that we will now use for both discrete and procedural cases - as can be seen on the figure below.</p> <p> </p> <p>We still need additional data depending on what we choose. For discrete heightfields, we must first transform our world-space point \\(\\mathbf{p}\\) to the space in which our samples live (grid-space), and compute the interpolation between our samples. We will use bilinear interpolation in this example. On the other hand, for procedural heightfields, we need to write the mathematical function that compute the altitude. Here we will use a cosinus, which is of course in no way realistic but still works. </p> DiscreteProcedural <pre><code>// A minimalist discrete heightfield class\nclass DiscreteHeightField extends BaseHeightField {\n    // Size of the 2D data elevation array\n    nx = 256;\n    ny = 256;\n    data = null; // Altitude data\n\n    constructor(horizontalExtents, verticalExtents, nx, ny, data) {\n        super(horizontalExtents, verticalExtents);\n        this.nx = nx;\n        this.ny = ny;\n        this.data = data;\n    }\n\n    /**\n    * Bilinear interpolation of a set of values.\n    * a00, a10, a11, a01: values to interpolate.\n    * u, v: interpolation factors along x/y axis.\n    */\n    Bilinear(a00, a10, a11, a01, u, v) {\n        return (1 - u) * (1 - v) * a00 \n            + (1 - u) * (v) * a01 \n            + (u) * (1 - v) * a10 \n            + (u) * (v) * a11;\n    }\n\n    // Fetch the elevation data from grid indicies\n    SampleGrid(i, j) {\n        return this.data[i * this.ny + j] * this.verticalExtents.y;\n    }\n\n    // Compute the altitude of a 2D point using bilinear interpolation\n    Elevation(p) {\n        let d = new Vector2(\n            this.bboxMax.x - this.bboxMin.x,\n            this.bboxMax.y - this.bboxMin.y\n        );\n\n        let q = p.clone();\n        q.sub(this.bboxMin);\n\n        let u = q.x / d.x;\n        let v = q.y / d.y;\n\n        // Scale\n        u *= (this.nx - 1);\n        v *= (this.ny - 1);\n\n        // Integer coordinates\n        let i = Math.floor(u);\n        let j = Math.floor(v);\n\n        // Local coordinates within cell\n        u -= i;\n        v -= j;\n\n        return this.Bilinear(\n            this.SampleGrid(i, j), this.SampleGrid(i + 1, j), \n            this.SampleGrid(i + 1, j + 1), this.SampleGrid(i, j + 1), \n            u, v\n        );\n    }\n}\n</code></pre> <pre><code>// Minimalist procedural heightfield class\nclass ProceduralHeightField extends BaseHeightField {\n    constructor(horizontalExtents, verticalExtents) {\n        super(horizontalExtents, verticalExtents);\n    }\n\n    // Compute the altitude of a 2D point procedurally\n    Elevation(p) {\n        return Math.cos(p.x) + Math.cos(p.y);\n    }\n}\n</code></pre> <p>You probably noted that the discrete heightfield class is much longer than the procedural one. The difference is that the provided code works for any set of data stored on a regular grid, while the procedural function must be modified in its mathematical expression if you intend to modify the output, even slightly. </p>"},{"location":"terrain/intro/#rendering-a-heightfield","title":"Rendering a Heightfield","text":"<p>So far we mostly talk about the internal representation of a heightfield, let it be discrete or procedural. But since we are doing Computer Graphics, we need a way to render these heightfields on the screen. As always, we have multiple options for that. </p>"},{"location":"terrain/intro/#polygonization","title":"Polygonization","text":"<p>The classical way is to create a 3D mesh from the heightfield, and render it using traditional rasterization. Because we manipulate grid-based heightfield, it is straightforward to create a triangle mesh for it: each cell can be represented using four vertices and two triangles. You can think of this as a subdivided plane mesh. The code for this is the following:</p> <pre><code>/**\n* Basic 3D triangle mesh data structure.\n*/ \nclass Mesh {\n    vertices = null;\n    normals = null;\n    triangles = null;\n\n    constructor(vertices, normals, triangles) {\n        this.vertices = vertices;\n        this.normals = normals;\n        this.triangles = triangles;\n    }\n}\n\n/**\n* Create and return a 3D mesh representing a heightfield, with vertices, normals, and triangles.\n* hf: heightfield, which should provide a Vertex(x, y) function.\n* nx, ny: discretization of the desired mesh along x/y axes.\n*/\nCreateHeightFieldMesh(hf, nx, ny) {\n    var vertices = [];\n    var normals = [];\n    var triangles = [];\n\n    // Create vertices\n    for (var i = 0; i &lt; nx; i++) {\n        for (var j = 0; j &lt; ny; j++) {\n            vertices.push(hf.Vertex(i, j, nx, ny));\n            normals.push(new Vector3(0, 0, 0));\n        }\n    }\n\n    // Compute triangle indices\n    for (var i = 0; i &lt; nx - 1; i++) {\n        for (var j = 0; j &lt; ny - 1; j++) {\n            // Triangle 1\n            triangles.push(i * ny + j);\n            triangles.push((i + 1) * ny + j);\n            triangles.push((i + 1) * ny + j + 1);\n\n            // Triangle 2\n            triangles.push(i * ny + j);\n            triangles.push((i + 1) * ny + j + 1);\n            triangles.push(i * ny + j + 1);\n        }\n    }\n\n    // Compute normals from triangles\n    for (var i = 0; i &lt; triangles.length; i += 3) {\n        let a = vertices[triangles[i + 0]].clone();\n        let b = vertices[triangles[i + 1]].clone();\n        let c = vertices[triangles[i + 2]].clone();\n\n        let ba = b;\n        ba.sub(a);\n        let n = ba.cross(c.sub(a)).normalize();\n        normals[triangles[i + 0]].add(n);\n        normals[triangles[i + 1]].add(n);\n        normals[triangles[i + 2]].add(n);\n    }\n    for (var i = 0; i &lt; normals.length; i++) {\n        normals[i].normalize();\n    }\n\n    return new Mesh(vertices, normals, triangles);\n}\n</code></pre> <p>Tip</p> <p>Creating a mesh is possible for both discrete and procedural representations discussed so far. The only requirement is that the heightfield should provide a function to compute the altitude of a 2D point. However, note that by discretizing a procedural heightfield, we loose the compact memory aspect.</p> <p>As mentioned before, creating a triangle mesh has a cost regarding memory: you need to explicitely store vertex and triangle data on the GPU. Thus, if your discretization is high, the memory impact will also be high, which can be a limiting factor.</p> <p>Note</p> <p>Note that the resolution of our discrete heightfield has no connection with the resolution of our mesh: we can completely create a 1024x1024 mesh out of a 256x256 heightfield thanks to interpolation. However, this may lead to visual artifacts, especially when using only bilinear interpolation.</p>"},{"location":"terrain/intro/#sphere-tracing","title":"Sphere tracing","text":"<p>An alternative which shines best for procedural representations is to avoid the creation of a 3D mesh and render the terrain directly using raymarching or sphere tracing. While being theoritically elegant and simple to implement, this is however a little less adapted to current graphics and physics pipelines, which mainly work with triangle meshes. For a procedural heightfield, another downfall is that the rendering performance is directly tied to the complexity of the underlying function, which can quickly get really complicated.</p> <p>Note</p> <p>There are many ways to optimize the evaluation of a procedural function (for heightfields, or more generally implicit surfaces), including bounding volume hierarchies, expression simplification, and many others. The guide may be extended to include these in the (long-term) future.</p> <p>In this guide, we will mostly use the mesh representation and work with heightfields of relatively low resolution. When appropriate, a slider to modify the grid discretization will be exposed. If you want to learn more about sphere tracing terrains, you can take a look at shadertoy, which is full of great examples.</p>"},{"location":"terrain/intro/#interactive-example","title":"Interactive Example","text":"<p>All sections in this guide will be illustrated with figures and interactive examples thanks to Three.js. The one below uses the classes created in this page, and shows both discrete and procedural heightfields rendered as 3D meshes. The discrete version is initialized from a small DEM of the french alps. Move around the scene with the mouse!</p>"},{"location":"terrain/intro/#appendix-storing-heightfields-as-images","title":"Appendix: Storing Heightfields as Images","text":"<p>A typical way of storing heightfield data on a disk is to use images, which makes complete sense because we store a single elevation value for each grid sample. You can find many examples of this online, as DEMs are typically shared as PNG files. However, an image only provides incomplete information about a terrain: there is no way to know the world space extent nor the altitude range. It is thus not unusual to see online posts with terrains exaggerated vertically or horizontally. This is a good reminder that terrains are not images.</p> <p> Example of images representing terrains, with no way of telling what is the actual horizontal and vertical extents. Left is a DEM of the Alps with a 12km horizontal extent, and a altitude range of [205, 4805] meters. Right is a procedural ridge noise baked with no real world-space dimensions. </p> <p>There is no real solution to this problem, except that you should provide additional information alongside the image file of your heightfield. Image files are still vastly used because they are easy to share and can be opened and edited using various softwares. </p>"},{"location":"terrain/intro/#appendix-going-further","title":"Appendix: Going further","text":"<p>Different models were developed throughout the years to represent a terrain on a computer - for the discrete case we covered regular heightfields, which are the most popular representation, but there are others that I did not cover:</p> <ul> <li>Hexagon and triangular fields [Dixon et al. 1994]</li> <li>Combinatorial maps [Crespin et al. 2014]</li> </ul>"},{"location":"terrain/intro/#associated-files","title":"Associated files","text":"<p>Files associated with this page are available here.</p>"},{"location":"terrain/procedural/curve_based_primitives/","title":"Curve based primitives","text":""},{"location":"terrain/procedural/curve_based_primitives/#curve-based-primitives","title":"Curve-based Primitives","text":""},{"location":"terrain/procedural/curve_based_primitives/#distance-to-a-curve","title":"Distance to a curve","text":""},{"location":"terrain/procedural/curve_based_primitives/#quadric-curve","title":"Quadric curve","text":""},{"location":"terrain/procedural/curve_based_primitives/#cubic-curve","title":"Cubic curve","text":""},{"location":"terrain/procedural/curve_based_primitives/#putting-that-on-a-terrain-rivers-roads-canyons","title":"Putting that on a terrain: rivers, roads, canyons","text":""},{"location":"terrain/procedural/curve_based_primitives/#going-further","title":"Going further","text":""},{"location":"terrain/procedural/designing_operators/","title":"Designing operators","text":""},{"location":"terrain/procedural/designing_operators/#designing-operators","title":"Designing operators","text":""},{"location":"terrain/procedural/designing_operators/#enhancing-a-single-primitive","title":"Enhancing a single primitive","text":"<p>TODO: talk about transformation, warping, noise addition maybe?</p>"},{"location":"terrain/procedural/designing_operators/#combining-multiple-primitives-together","title":"Combining multiple primitives together","text":"<p>TODO: show a blend operator and a replace. </p>"},{"location":"terrain/procedural/designing_operators/#going-further","title":"Going further","text":"<p>TODO: exercise for the reader to design a new operator, such as ??? Find an idea.</p>"},{"location":"terrain/procedural/noise_for_terrains/","title":"Noise for terrains","text":""},{"location":"terrain/procedural/noise_for_terrains/#using-noise-for-terrain-generation","title":"Using Noise for Terrain Generation","text":"<p>Noise is a powerful tool that has been applied in many (if not all) subdomains of Computer Graphics. Terrain generation is no exception. In fact, using noise to generate mountains was one of the first application, going back as far as the late eighties with the seminal work of Kenton Musgrave. </p> <p>For terrains, the core idea is to use the scalar value returned by the noise as the altitude at a given point. You can think of this as a world-space plane, with the elevation of points defined by the noise function. Below is an example of the same noise rendered on a 2D texture and on a 3D mesh.</p> <p> </p> <p>Now let's see how to do that in practice. Our goal is to define the procedural elevation function \\(h\\) as some sort of noise function \\(n\\). Recall that \\(h\\) takes a 2D point in input and return the elevation, or put otherwise it is defined as \\(h(\\mathbf{p}) : \\mathbb{R}^2 \\rightarrow \\mathbb{R}\\).</p> <p>Note</p> <p>If you want to dig into the details of how noise functions work internally, please refer to this page.</p>"},{"location":"terrain/procedural/noise_for_terrains/#our-first-noise-based-terrain","title":"Our first noise-based terrain","text":"<p>Noise functions are simply dependent on the position at which they are evaluated - they thus belong to the category of procedural functions. They require only very few data to be stored and rely on a procedure to compute a scalar value. If we extend our ProceduralHeightField class introduced in the previous part, we may define the elevation function \\(h\\) again using our Perlin noise:</p> <pre><code>class ProceduralHeightField extends BaseHeightField {\n    constructor(horizontalExtents, verticalExtents) {\n        super(horizontalExtents, verticalExtents);\n    }\n\n    // Compute the altitude of a 2D point procedurally using Perlin noise\n    Elevation(p) {\n        return amplitude * perlin.noise(x * freq, y * freq, 0.0);\n    }\n}\n</code></pre> <p>This gives us the following result. Use the mouse to turn around it!</p> <p>Notice the impact of amplitude which vertically stretch the terrain, and frequency which changes the horizontal scales of the bumps. These two values are just a way to modify the output of our function according to our needs. </p> <p>Tip</p> <p>For the noise algorithm, we rely on Three.js Perlin noise implementation, which was itself used to showcase a procedural terrain here with the code here.</p> <p>Another common control not showcased here is the number of successive octaves, which is used for doing sum of perlin noise, also called a fractal noise. If we were to write the equivalent formula and code for a fractal sum of noise, it would look like this:</p> MathCode <p>\\(h(\\mathbf{p}) = \\sum_{i=0}^{o} a_i n (\\mathbf{p} f_i)\\)</p> <p>\\(a_i = a_0 / 2i\\)</p> <p>\\(f_i = f_0~2i\\)</p> <pre><code>/**\n* Fractal sum of perlin noise.\n* p: 2D point with x and y members.\n* a0 is the amplitude of the first octave.\n* f0 is the frequency of the first octave.\n*/\nfunction computeElevation(p) {\n    var ret = 0.0;\n    var a = a0;\n    var f = f0;\n    for (var i = 0; i &lt; o; i++) {\n        ret += a * perlin.noise(p.x * f, p.y * f, 0.0);\n        a *= 0.5;\n        f *= 2.0;\n    }\n    return ret;\n}\n</code></pre> <p>With \\(a_0\\) the base amplitude, \\(f_0\\) the base frequency. Notice how at the same time, we increase the frequency of successive octaves, and decrease their amplitude. This function is also commonly referred to as a turbulence, or fractional brownian motion (fBm for short). </p> <p>Info</p> <p>The multipliers for the amplitude and frequency are respectively called the lacunarity and persistence. You may slightly change their values and create terrains with slightly different looks. Try it!</p> <p>At this point you may not really believe that noise function can create realistic or at least visually appealing terrains. You can play around with the amplitude, frequency and will probably improve the results quite a lot. However, noise-based terrains still have several limitations. </p>"},{"location":"terrain/procedural/noise_for_terrains/#the-issues-of-noise","title":"The issues of Noise","text":"<p>Creating terrains using fractal noise has been done extensively in video games for multiple decades. While you can definitely get a mountainous look for your terrain, getting a proper valley for instance might be more difficult, or even impossible if you limit yourself to simple, uniform fractal noise. We could list some of the limitations of the above example, including:</p> <ul> <li> <p>No valleys: you either get a very mountainous terrain or a very flat terrain, but having a mix of both is difficult.</p> </li> <li> <p>You may notice the same kinds of pattern everywhere. This is one interesting property of noise function: self-similarity. In our case, it's also a limitation.</p> </li> <li> <p>Mountains created with noise are only just isolated peaks, and lacks the ridge structure typically found in real mountain ranges.</p> </li> </ul> <p>In the end, it seems that noise is only capable of generating small bumps. Can we alleviate this issue somehow?</p>"},{"location":"terrain/procedural/noise_for_terrains/#multifractals-to-the-rescue","title":"Multifractals to the rescue?","text":"<p>Some of these problems can be partially solved by using a more advanced technique called a multifractal noise. The core idea is to modulate the amplitude \\(a\\) of successive octave based on the noise value of previous iterations. This way areas with a low amplitude at iteration \\(k\\) will get a noise value of lower amplitude at iteration \\(k+1\\), and the opposite will happen for mountainous areas. </p> <p>Let \\(t_k\\) denote the fractal noise at iteration \\(k\\), this gives us the following maths and code:</p> MathCode <p>\\(t_{k+1}(\\mathbf{p}) = t_k(\\mathbf{p}) + \\alpha(t_k(\\mathbf{p}))~a_{k+1}~n(\\mathbf{p}f_i) \\qquad t_0(\\mathbf{p}) = a_0~n(\\mathbf{p}f_i)\\)</p> <pre><code>/**\n* Weight function for multifractal perlin noise.\n* t accumulated turbulence value so far.\n* o current iteration number\n*/\nfunction alpha(t, o) {\n  if (o == 0) {\n    return 1.0;\n  }\n  let frequency = 1.0;\n  let H = 0.75;\n  for (let i = 0; i &lt; o; i++) {\n    frequency *= 2.0;\n  }\n  return t * Math.pow(frequency, -H);\n}\n\n/**\n* Multifractal perlin noise.\n* p: 2D point with x and y members.\n* a0 is the amplitude of the first octave.\n* f0 is the frequency of the first octave.\n*/\nfunction computeElevation(x, y) {\n  var ret = 0.0;\n  var f = f0;\n  for (var i = 0; i &lt; o; i++) {\n    ret += alpha(ret, i) * perlin.noise(x * f, y * f, 0.0);\n    f *= 2.0;\n  }\n  return a0 * ret;\n}\n</code></pre> <p>The function \\(\\alpha : \\mathbb{R} \\rightarrow \\mathbb{R}\\) computes the weight of the next octave \\(k\\) based on the total accumulated value so far \\(t_k\\).</p> <p>Below is an example that shows different types of noise for generating terrain shapes, including classical perlin and ridge noise, as well as their multifractal variants. Play around with the different settings to get a feel of how noise behaves.</p> <p>Multifractals still do not solve everything. However, the idea of using procedural functions to generate shapes is interesting and can be pushed further: what if we could create function to represent dunes, cliffs, mountains, mountain ridges, rivers, and more? </p> <p>This will be the subject of the following chapters, where we design a library of procedural primitives and operators to create more visually interesting and varied terrains.</p>"},{"location":"terrain/procedural/noise_for_terrains/#going-further","title":"Going further","text":"<p>If you want to go further, you may try to use other kinds of noise to create terrains, for instance Worley (or cellular) noise, its fractal variants, Billowy noise, or try to model different effects such as domain warp. </p>"},{"location":"terrain/procedural/noise_for_terrains/#associated-files","title":"Associated files","text":"<p>Files associated with this page are available here.</p>"},{"location":"terrain/procedural/our_first_primitive/","title":"Our first primitive","text":""},{"location":"terrain/procedural/our_first_primitive/#creating-our-first-terrain-primitive","title":"Creating our First Terrain Primitive","text":"<p>Simply using uniform fractal or multifractal noise is not enough for creating realistic terrains: we simply lack the variety found in real terrains. The compact procedural aspect of noise functions remains interesting - we are however limited by our ability to design a function that represents the desired landforms. In this part we will see how to design such shapes only using basic mathematical tools.</p> <p>The core idea of this chapter is that procedural heightfields are not limited to noise: we can use other functions, such as trigonometric functions (cos, sin, tan) as well as geometric skeletons (explained in a bit). You may think of all of these as 1D or 2D functions of different shapes that we will combine together using simple operators such as addition and multiplication, to achieve a desired appearance. In concrete terms, we will design terrain primitives, and later combine them together to create a large-scale terrain.</p> <p>This may still be a little abstract - Let's take an example: How about creating sand dunes? \ud83c\udfdc\ufe0f</p>"},{"location":"terrain/procedural/our_first_primitive/#designing-transverse-dunes","title":"Designing Transverse Dunes","text":"<p>Sand dunes are a very good and educational example when it comes to creating terrain primitives. For those not familiar with how sand dunes look like, the figure below recaps the most common shapes identified by geomorphologists.</p> <p> </p> <p>Sand dunes emerge from the interplay between wind of variable strength and direction over time, sand, and bare bedrock underneath. Here we focus on transverse dunes, which exhibit regular longitudinal patterns orthogonal to the wind direction. </p> <p>The first observation is that the pattern is repeating over space at mostly regular intervals; the second observation is that the atomic repeating element is almost a straight line. If we take a side-view perspective, these dunes almost look like... a cosinus function. This is actually the only thing that we need to model such shape: we can use a 1D cosinus as our procedural heightfield function \\(h\\), taking as parameter the \\(x\\) or \\(y\\) coordinate of the point \\(\\mathbf{p}\\):</p> MathCode <p>\\(h(\\mathbf{p}) : \\cos(\\mathbf{p}_x)\\)</p> <pre><code>function computeElevation(p) {\n    return Math.cos(p.x);\n}\n</code></pre> <p>Put in 3D, it looks like this.</p> <p> </p> <p>This is already quite good, although a bit 'hilly'. We are missing the sharp aspect of crests at the top of the dunes. This can done basically inverting the shape of our cosinus using an absolute value:</p> MathCode <p>\\(h(\\mathbf{p}) : 1 - | \\cos(\\mathbf{p}_x) |\\)</p> <pre><code>function computeElevation(p) {\n    return 1 - Math.abs(Math.cos(p.x));\n}\n</code></pre> <p>Which leads to the following 3D result. Notice how we managed to create sharp features using a simple absolute value. This trick is similar to the one used to create ridge noise.</p> <p> </p> <p>This is already pretty satisfying, can we do better? The result is still lacking some irregularities: nothing is as straight and as regular in real life. Noise is a great tool for such task: it is increadibly useful to add variety and details on terrain primitives. There are several ways to do this: for instance a small layer of noise may be added at the top or bottom of the dunes, or a warp the input position may be used to to add irregularities to the crest directions. You may refer to the interactive example below to compare the different versions with various additional parameters.</p> <p>For the rest, the only limitation is your imagination and your ability to picture the combination of different mathematical functions. It's fun to do but still require a bit of practice.</p> <p>Tip</p> <p>It is sometimes easier to visualize and design shapes in 1D rather than 2D or 3D: for that, Desmos is a great tool that I use regularly. Shadertoy is also a great source of inspiration.</p>"},{"location":"terrain/procedural/our_first_primitive/#geometric-skeletons","title":"Geometric Skeletons","text":"<p>The sand dunes example is good and all, but what if our landforms is not periodic but rather punctual? For instance, what if we want to design a single mountain peak, a hill, or a crater? For that, trigonometric functions may be a little less useful - we need another tool, which we refer to as geometric skeletons.</p> <p>TODO: explain point, disk, and curve skeleton. Provide distance formula for all, and design a mountain primitive</p>"},{"location":"terrain/procedural/our_first_primitive/#designing-a-mountain-primitive","title":"Designing a Mountain primitive","text":""},{"location":"terrain/procedural/our_first_primitive/#math-function-utilities","title":"Math function utilities","text":"<p>TODO: recap all useful math functions to design terrain primitives</p>"},{"location":"terrain/procedural/our_first_primitive/#going-further","title":"Going further","text":""},{"location":"terrain/procedural/terrain_construction_tree/","title":"Terrain construction tree","text":""},{"location":"terrain/procedural/terrain_construction_tree/#terrain-construction-trees","title":"Terrain Construction Trees","text":"<p>TODO: introduce the more formal notion of construction tree, or graph of primitive and operators. This is very classical paradigm in procedural modeling, and in computer graphics in general. These structures have interesting properties, their queries can be optimized, and they can be extended with as many primitives and operators that you may design.</p>"},{"location":"terrain/procedural/terrain_construction_tree/#going-further","title":"Going Further","text":"<ul> <li>Cite JD thesis as a reference (in french though), and the associated article.</li> <li>Cite multi-material extensions with other trees to represent vegetation or water for instance.</li> </ul>"},{"location":"terrain/simulation/simulation_intro/","title":"Introduction","text":""},{"location":"terrain/texturing/texturing_intro/","title":"Introduction","text":""},{"location":"terrain/volumetric/going_3D/","title":"What is a Volumetric Terrain?","text":""},{"location":"terrain/volumetric/implicits/","title":"Using Implicit Surfaces","text":""},{"location":"terrain/volumetric/voxels/","title":"Using Voxels","text":""}]}