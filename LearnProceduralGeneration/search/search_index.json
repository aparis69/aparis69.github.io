{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Welcome to the Procedural Generation guide. This is aimed at people that want to learn more about world generation, featuring terrain, ecosystem simulation, river animation, just to name a few. On top of being as accessible as possible to everyone, the goal here is to provide explanations, mathematical formulas, clear code, demos, and exercises for all examples. </p> <p>Interactive demos are made possible thanks to the great Three.js library. Only basic knowledge in Computer Graphics should be required to go through this guide.</p> <p>Warning</p> <p>This guide is currently (as of 2024) being written and is thus a work in progress. Except significant changes, errors, and new content being added. Feedback is welcome.</p> <p>Note</p> <p>Todolist:</p> <ul> <li>Add a screenshot of all the interactive examples on this page. This should be as colorful as possible.</li> <li>Find some good default parameters for each example. Visuals must be great at first glance.</li> <li>Each page should have at least one interactive example to play with.</li> <li>It should be easy to modify the example, maybe directly in the page? Or by clicking on a button that opens a setup JS playground?</li> <li>At the beginning (or end?) of each page, do a 'Summary' or 'Takeaways' of the main points.</li> </ul>"},{"location":"#what-is-procedural-generation","title":"What is Procedural Generation?","text":"<p>Procedural Generation refers to a way of creating digital content, let it be 3D models, textures, patterns, colors, and so on. The idea is that data is generated more or less  automatically through the use of an algorithm or a procedure, rather than created manually. Generating content procedurally can provide many advantages, including scalability (with the ability to generate a large set of different shapes), memory efficiency (by only storing the generation procedure, and not its output), and a lot more. Procedural generation is a powerful tool that artists use in their day to day life.</p> <p>Computer Graphics has been a great playground for Procedural Generation throughout the years, with the first papers going back to 1990 with Frank Ebert.</p> <p>Note that there is not a single definition for these terms. This is just my personal one and the one that will be used throughout this guide.</p>"},{"location":"#do-i-need-to-know-math","title":"Do I need to know Math?","text":"<p>Only a very basic knowledge of linear algebra and math is expected. When possible, I provide the equivalence between math and code so that it is accessible to more people. For vector and matrice types, we will extensively use the strutures provided by Three.js, such as Vector2,   Vector3, and Matrix4.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>This guide is separated in multiple parts, each one covering a different aspect of world generation. These are mostly independent and can be read in any order. All sections are illustrated with interactive examples that run directly in your web browser. Small exercises are mentioned at the end of each page, if you want to go deeper into a given topic.</p> <ul> <li>\ud83d\udcda Fundamentals, which covers some basics that help you understand the next parts. You can skip this section, or just go back to it from time to time if you don't understand some concept. It also contains a glossary of all the technical terms used throughout the guide.   </li> <li>\u26f0\ufe0f Terrain, where you will about the different techniques for generating terrains, including procedural noise and erosion simulation.</li> <li>\ud83c\udf0a Rivers, with everything you need to know to generate realistic river trajectories as well as animated water surfaces.</li> <li>More to come!</li> </ul> <p>The concepts presented in this guide are not new groundbreaking research. Everything has either been published in research papers, used in multiple video games, or written and explained in various blogs. The end goal of this guide is to be as complete as possible and become a go-to reference for Procedural World Generation.</p>"},{"location":"#faq","title":"FAQ","text":"Why another Procedural Generation guide? <p>There are a lot of great resources online to get started - but none of them was interactive and accessible enough for my tastes. </p> Can I use the code written here? <p>The code that uses Three.js is under MIT License - and the rest, written by me, is released under MIT unless specified otherwise.</p> Why Javascript and not C++? <p>It is true that Computer Graphics topics in general are usually explained in C++, but I wanted this guide to be as interactive as possible, which is easier in Javascript (although I am not a fan nor an expert of this language).</p> I saw an error/a typo. Where can I report it? <p>You can send me an email at axel.paris69@gmail.com.</p> Will you cover X in your guide? <p>I cannot guarantee that. What I can say is that I want to write about this list of topics in the near future: trees and ecosystem simulation, building, cities, and road generation, and clouds. No timeline though.</p>"},{"location":"#giving-feedback","title":"Giving feedback","text":"<p>As this guide has been mostly written by a single person, feedback is more than welcome. If you see something that could be explained better or is simply wrong, you can email me directly at axel.paris69@gmail.com.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#about","title":"About","text":""},{"location":"about/#code","title":"Code","text":"<p>All the code that involves the use of Three.js is under the MIT License, but the rest of this guide is released under either Public Domain or MIT license, whatever fits you best.</p>"},{"location":"about/#about-the-author","title":"About the Author","text":"<p>My name is Axel Paris and I am currently a Research Scientist at Adobe. I defended my PhD in Terrain Modeling and Generation in 2023. The concepts presented here were part of my daily life throughout the years, and I still use many today. If you to know more about me, you can go to my personal website.</p>"},{"location":"about/#references","title":"References","text":"<p>Below is a non-exhaustive lists of resources used to write this blog, along with some explanations. There are many gems in there, so feel free to explore, and also report dead links to me at axel.paris69@gmail.com.</p>"},{"location":"fundamentals/glossary/","title":"Glossary","text":""},{"location":"fundamentals/glossary/#dictionary","title":"Dictionary","text":"<p>TODO: definitions of all the technical terms used in the guide, alongside the chapter in which they are used.</p> <ul> <li>Elevation model</li> <li>Heightfield</li> <li>Volumetric model</li> <li>Voxel</li> <li>Implicit Surface</li> <li>Procedural noise</li> <li>Turbulence</li> <li>Interpolation</li> <li>Sphere tracing</li> <li>Erosion</li> <li>Geomorphology</li> <li>Karst</li> <li>Overhangs</li> <li>Construction tree</li> <li>3D Mesh</li> <li>River</li> <li>Geometric Skeleton</li> <li>Breaching</li> <li>Hydrology</li> <li>Warping</li> <li>Linear, Quadric, Cubic, Quartic</li> </ul>"},{"location":"fundamentals/implicits/","title":"Implicits","text":""},{"location":"fundamentals/implicits/#implicit-surfaces","title":"Implicit surfaces","text":"<p>TODO: what is an implicit surface, distinction between discrete and analytic. Briefly mention different models (blobs, SDFs at least), how they are used in CSG/Shape Modeling in general, and also in Machine Learning. Mention the 2D and 3D cases, and also maybe animated implicits? Mention shadertoy.</p>"},{"location":"fundamentals/interpolation/","title":"Interpolation","text":""},{"location":"fundamentals/interpolation/#interpolating-data","title":"Interpolating Data","text":"<p>Bilinear interpolation, bi-cubic interpolation.</p>"},{"location":"fundamentals/noise/","title":"Noise","text":""},{"location":"fundamentals/noise/#procedural-noise","title":"Procedural Noise","text":"<p>TODO: introduce what is noise, and give a brief overview of the different types, as well as references on nice libraries (FastNoise, things available in UE or Unity, etc...). Try to keep the overview 2D only for textures, do not mention terrains yet and stay general enough. Speak about higher dimensional noises as well.</p> <p>List of types that should be mentioned/shown:</p> <ul> <li>Perlin/Gradient</li> <li>Value</li> <li>Ridge</li> <li>Simplex</li> <li>Cellular</li> <li>Sparse Convolution</li> <li>Gabor</li> <li>Explain what is a Turbulence, a fractal sum as well.</li> </ul>"},{"location":"fundamentals/noise/#going-further","title":"Going Further","text":"<p>Exercise: </p> <ul> <li>What is the max of a Turbulence parameterized by a, f, o?</li> </ul>"},{"location":"rivers/hydrology_correction/","title":"The Importance of Breaching","text":""},{"location":"rivers/hydrology_correction/#going-further","title":"Going Further","text":""},{"location":"rivers/intro/","title":"Introduction","text":""},{"location":"rivers/intro/#what-is-not-covered-here","title":"What is not covered here","text":""},{"location":"rivers/river_generation/","title":"Generating River Networks","text":""},{"location":"rivers/river_generation/#going-further","title":"Going Further","text":""},{"location":"terrain/intro/","title":"Introduction","text":""},{"location":"terrain/intro/#introduction","title":"Introduction","text":"<p>There are several ways to represent a terrain on a computer. This choice mainly depends on the target application (video games, scientific simulations), the type of landforms you want to represent (mountain ranges, caves, hills), and the scale at which you work. We first separate terrain representations in two: there are elevation models, and volumetric models. Elevation models are the most popular representation, as they provide a sufficiently accurate approximation while being compact in memory. However, they cannot represent volumetric landforms, such overhangs and arches, which are crucial scenic elements of virtual worlds. </p>"},{"location":"terrain/intro/#getting-started","title":"Getting started","text":"<p>In this guide, the main focus is on elevation models. The remainder of this page cover the basic of what is a heightfield, how to represent in memory, and render them on a computer. We will create the base classes and modules that will be used in the next sections. After that, the terrain section is organized in several subsections:</p> <ul> <li>\ud83c\udf0d Procedural, which covers everything you need to know on how to use noise functions and combine them to create beautiful terrains.</li> <li>\ud83c\udfd4\ufe0f Simulation, where you will learn about physically-based algorithms that simulates erosion on a given terrain to increase realism.</li> <li>\ud83e\udea8 Volumetric, where we depart from elevation models and explain how to create underground caves, overhangs, and arches.</li> </ul> <p>Tip</p> <p>While these have been written to be read in order, you may also jump to a given section, or completely skip some if you feel like it.</p>"},{"location":"terrain/intro/#heightfields","title":"Heightfields","text":"<p>Elevation models are also called planar models, or heightfields. Here we only represent the surface of the terrain and forget about the interior. As we will see, this is a powerful approximation particularly suited to terrains. More formally, a heightfield is defined by a mathematical function \\(h: \\mathbb{R}^2 \\rightarrow \\mathbb{R}\\) that computes the altitude (the z coordinate) of a point \\(\\mathbf{p}\\) in 2D space.</p> <p> </p> <p>If we were to write the equivalence between this mathematical function and Javascript code, it would look like this:</p> MathCode <p>\\(h(\\mathbf{p}) : \\mathbb{R}^2 \\rightarrow \\mathbb{R}\\)</p> <pre><code>/**\n* Elevation function for a heightfield.\n* p: 2D point with x and y members.\n*/\nfunction computeElevation(p) {\n    let h = ...;\n    return h;\n}\n</code></pre> <p>Now the remaining question is: how do we write the function \\(h\\), and its equivalent <code>computeElevation</code> in Javascript? There is no single answer but rather different options depending on what you need. The function \\(h\\) may be defined from a discrete set of samples or through procedural functions.</p>"},{"location":"terrain/intro/#discrete-vs-procedural","title":"Discrete vs Procedural","text":"<p>We consider that the only requirement for  \\(h\\) is that it must compute the altitude of any point in 2D space, which means that there is a common interface between discrete and procedural representations.</p> <p>Discrete representations are the most common for terrains. Elevation is computed as the interpolation of altitude values stored at discrete points, usually distributed on a regular grid. </p> <p>Note</p> <p>Discrete samples usually follow a regular grid pattern for lots of practical reasons, but samples may be distributed in other ways. For instance, it is perfectly valid to distribute samples according to a Delaunay triangulation. This won't be covered in this guide though.</p> <p> </p> <p>Discrete representations can be easily edited: we only need to modify the elevation stored at the discrete sample points. They are also popular because these samples may be initialized from real data. This type of heightfields is called a DEM (Digital Elevation Model), and represents rasterized terrain data from satellite images. </p> <p>The requirement for discrete heightfields is that the data must exist somewhere in memory. Depending on the resolution of the grid, this may become impractical. For instance, if we consider that altitudes are stored as 32-bits float (4 bytes), a full resolution \\(8k \\times 8k\\) terrain represents 256mo, which is already pretty large and does not even encompasses colors or other common attributes.</p> <p>Procedural representations are the complete opposite. Here, we do not explicitely store anything in memory but rely on a mathematical function to compute the elevation at a given point. This function may be constructed in multiples ways, but always indirectly through math and code, as opposed to manually editing a specific point as it is the case with discrete heightfields. </p> <p>The advantage is that you can theoritically represent infinitely detailed terrains without being limited by memory - you are only limited by the expressiveness of the underlying function. However, a typical downside of procedural models is that they require a lot more computations than discrete models, as the mathematical expression usually involves more operations than the interpolation of discrete samples.</p> <p>Tip</p> <p>The memory vs computation tradeoff is a typical one in Computer Graphics, and in Computer Sciences in general. There is no universal answer to which approach you should take. It all depends on your problem setting. But it is important to understand the pros and cons of both approaches.</p> <p>We will extensively cover how to create beautiful terrains using procedural functions in the next part of this guide. </p>"},{"location":"terrain/intro/#a-minimalist-implementation","title":"A Minimalist Implementation","text":"<p>Even though discrete and procedural models differ in many ways, there is a common interface to both that we can abstract to facilitate our work in the next sections. We will first create a <code>BaseHeightField</code> class that contains common functionalities and data.</p> <pre><code>class BaseHeightField {\n    // Public members\n    horizontalExtents = new Vector2(10, 10);\n    verticalExtents = new Vector2(0, 10);\n    bboxMin = new Vector2(-5, -5);\n    bboxMax = new Vector2(5, 5);\n\n    constructor(horizontalExtents, verticalExtents) {\n        this.horizontalExtents = horizontalExtents;\n        this.verticalExtents = verticalExtents;\n        this.bboxMin = new Vector2(\n            -this.horizontalExtents.x / 2.0,\n            -this.horizontalExtents.y / 2.0\n        );\n        this.bboxMax = new Vector2(\n            this.horizontalExtents.x / 2.0,\n            this.horizontalExtents.y / 2.0\n        );\n    }\n\n    // Compute altitude at a given 2D point\n    // This is where procedural and discrete differ\n    Elevation(p) {\n        [...]\n    }\n\n    /* \n    * Compute the position of a vertex from a virtual grid indices and resolution\n    * i, j: grid indicies\n    * nx, ny: grid dimensions\n    */\n    Vertex(i, j, nx, ny) {\n        let cellDiagonal = new Vector2(\n          this.horizontalExtents.x / (nx - 1),\n          this.horizontalExtents.y / (ny - 1),\n        );\n        let p = new Vector2(\n            this.bboxMin.x + i * cellDiagonal.x, \n            this.bboxMin.y + j * cellDiagonal.y\n        );\n        return new Vector3(\n            p.x,\n            p.y,\n            this.Elevation(p)\n        );\n    }\n}\n</code></pre> <p>Note</p> <p>This class contains redundant data, which is on purposes to speed-up computation and facilitate reading. This is not the most optimal.</p> <p>This way, we factorize some class members: not matter the representation, a heightfield has three dimensions (two horizontals, one vertical). Another interesting thing that we are able to put here is the <code>Vertex</code> function, which computes a position on the heightfield over a virtual grid characterized by its dimensions. This will be very handy in the next sections when we will create a mesh out of our heightfield.</p> <p>Tip</p> <p>An important thing to note is that we need the minimum and maximum elevation of the terrain. No matter the representation, we usually manipulate altitudes in some normalized form, thus the need to transform to world-space at the end of the computation.</p> <p>Of course, this class is not enough by itself. It is just an abstraction layer that we will now use for both discrete and procedural cases - as can be seen on the figure below.</p> <p> </p> <p>We still need additional data depending on what we choose. For discrete heightfields, we must first transform our world-space point \\(\\mathbf{p}\\) to the space in which our samples live (grid-space), and compute the interpolation between our samples. We will use bilinear interpolation in this example. On the other hand, for procedural heightfields, we need to write the mathematical function that compute the altitude. Here we will use a cosinus, which is of course in no way realistic but still works. </p> DiscreteProcedural <pre><code>// A minimalist discrete heightfield class\nclass DiscreteHeightField extends BaseHeightField {\n    // Size of the 2D data elevation array\n    nx = 256;\n    ny = 256;\n    data = null; // Altitude data\n\n    constructor(horizontalExtents, verticalExtents, nx, ny, data) {\n        super(horizontalExtents, verticalExtents);\n        this.nx = nx;\n        this.ny = ny;\n        this.data = data;\n    }\n\n    /**\n    * Bilinear interpolation of a set of values.\n    * a00, a10, a11, a01: values to interpolate.\n    * u, v: interpolation factors along x/y axis.\n    */\n    Bilinear(a00, a10, a11, a01, u, v) {\n        return (1 - u) * (1 - v) * a00 \n            + (1 - u) * (v) * a01 \n            + (u) * (1 - v) * a10 \n            + (u) * (v) * a11;\n    }\n\n    // Fetch the elevation data from grid indicies\n    SampleGrid(i, j) {\n        return this.data[i * this.ny + j] * this.verticalExtents.y;\n    }\n\n    // Compute the altitude of a 2D point using bilinear interpolation\n    Elevation(p) {\n        let d = new Vector2(\n            this.bboxMax.x - this.bboxMin.x,\n            this.bboxMax.y - this.bboxMin.y\n        );\n\n        let q = p.clone();\n        q.sub(this.bboxMin);\n\n        let u = q.x / d.x;\n        let v = q.y / d.y;\n\n        // Scale\n        u *= (this.nx - 1);\n        v *= (this.ny - 1);\n\n        // Integer coordinates\n        let i = Math.floor(u);\n        let j = Math.floor(v);\n\n        // Local coordinates within cell\n        u -= i;\n        v -= j;\n\n        return this.Bilinear(\n            this.SampleGrid(i, j), this.SampleGrid(i + 1, j), \n            this.SampleGrid(i + 1, j + 1), this.SampleGrid(i, j + 1), \n            u, v\n        );\n    }\n}\n</code></pre> <pre><code>// Minimalist procedural heightfield class\nclass ProceduralHeightField extends BaseHeightField {\n    constructor(horizontalExtents, verticalExtents) {\n        super(horizontalExtents, verticalExtents);\n    }\n\n    // Compute the altitude of a 2D point procedurally\n    Elevation(p) {\n        return Math.cos(p.x) + Math.cos(p.y);\n    }\n}\n</code></pre> <p>You probably noted that the discrete heightfield class is much longer than the procedural one. The difference is that the provided code works for any set of data stored on a regular grid, while the procedural function must be modified in its mathematical expression if you intend to modify the output, even slightly. </p>"},{"location":"terrain/intro/#rendering-a-heightfield","title":"Rendering a Heightfield","text":"<p>So far we mostly talk about the internal representation of a heightfield, let it be discrete or procedural. But since we are doing Computer Graphics, we need a way to render these heightfields on the screen. As always, we have multiple options for that. </p>"},{"location":"terrain/intro/#polygonization","title":"Polygonization","text":"<p>The classical way is to create a 3D mesh from the heightfield, and render it using traditional rasterization. Because we manipulate grid-based heightfield, it is straightforward to create a triangle mesh for it: each cell can be represented using four vertices and two triangles. You can think of this as a subdivided plane mesh. The code for this is the following:</p> <pre><code>/**\n* Basic 3D triangle mesh data structure.\n*/ \nclass Mesh {\n    vertices = null;\n    normals = null;\n    triangles = null;\n\n    constructor(vertices, normals, triangles) {\n        this.vertices = vertices;\n        this.normals = normals;\n        this.triangles = triangles;\n    }\n}\n\n/**\n* Create and return a 3D mesh representing a heightfield, with vertices, normals, and triangles.\n* hf: heightfield, which should provide a Vertex(x, y) function.\n* nx, ny: discretization of the desired mesh along x/y axes.\n*/\nCreateHeightFieldMesh(hf, nx, ny) {\n    var vertices = [];\n    var normals = [];\n    var triangles = [];\n\n    // Create vertices\n    for (var i = 0; i &lt; nx; i++) {\n        for (var j = 0; j &lt; ny; j++) {\n            vertices.push(hf.Vertex(i, j, nx, ny));\n            normals.push(new Vector3(0, 0, 0));\n        }\n    }\n\n    // Compute triangle indices\n    for (var i = 0; i &lt; nx - 1; i++) {\n        for (var j = 0; j &lt; ny - 1; j++) {\n            // Triangle 1\n            triangles.push(i * ny + j);\n            triangles.push((i + 1) * ny + j);\n            triangles.push((i + 1) * ny + j + 1);\n\n            // Triangle 2\n            triangles.push(i * ny + j);\n            triangles.push((i + 1) * ny + j + 1);\n            triangles.push(i * ny + j + 1);\n        }\n    }\n\n    // Compute normals from triangles\n    for (var i = 0; i &lt; triangles.length; i += 3) {\n        let a = vertices[triangles[i + 0]].clone();\n        let b = vertices[triangles[i + 1]].clone();\n        let c = vertices[triangles[i + 2]].clone();\n\n        let ba = b;\n        ba.sub(a);\n        let n = ba.cross(c.sub(a)).normalize();\n        normals[triangles[i + 0]].add(n);\n        normals[triangles[i + 1]].add(n);\n        normals[triangles[i + 2]].add(n);\n    }\n    for (var i = 0; i &lt; normals.length; i++) {\n        normals[i].normalize();\n    }\n\n    return new Mesh(vertices, normals, triangles);\n}\n</code></pre> <p>Tip</p> <p>Creating a mesh is possible for both discrete and procedural representations discussed so far. The only requirement is that the heightfield should provide a function to compute the altitude of a 2D point. However, note that by discretizing a procedural heightfield, we loose the compact memory aspect.</p> <p>As mentioned before, creating a triangle mesh has a cost regarding memory: you need to explicitely store vertex and triangle data on the GPU. Thus, if your discretization is high, the memory impact will also be high, which can be a limiting factor.</p> <p>Note</p> <p>Note that the resolution of our discrete heightfield has no connection with the resolution of our mesh: we can completely create a 1024x1024 mesh out of a 256x256 heightfield thanks to interpolation. However, this may lead to visual artifacts, especially when using only bilinear interpolation.</p>"},{"location":"terrain/intro/#sphere-tracing","title":"Sphere tracing","text":"<p>An alternative which shines best for procedural representations is to avoid the creation of a 3D mesh and render the terrain directly using raymarching or sphere tracing. While being theoritically elegant and simple to implement, this is however a little less adapted to current graphics and physics pipelines, which mainly work with triangle meshes. For a procedural heightfield, another downfall is that the rendering performance is directly tied to the complexity of the underlying function, which can quickly get really complicated.</p> <p>Note</p> <p>There are many ways to optimize the evaluation of a procedural function (for heightfields, or more generally implicit surfaces), including bounding volume hierarchies, expression simplification, and many others. The guide may be extended to include these in the (long-term) future.</p> <p>In this guide, we will mostly use the mesh representation and work with heightfields of relatively low resolution. When appropriate, a slider to modify the grid discretization will be exposed. If you want to learn more about sphere tracing terrains, you can take a look at shadertoy, which is full of great examples.</p>"},{"location":"terrain/intro/#interactive-example","title":"Interactive Example","text":"<p>All sections in this guide will be illustrated with figures and interactive examples thanks to Three.js. The one below uses the classes created in this page, and shows both discrete and procedural heightfields rendered as 3D meshes. The discrete version is initialized from a small DEM of the french alps. Move around the scene with the mouse!</p>"},{"location":"terrain/intro/#appendix-storing-heightfields-as-images","title":"Appendix: Storing Heightfields as Images","text":"<p>A typical way of storing heightfield data on a disk is to use images, which makes complete sense because we store a single elevation value for each grid sample. You can find many examples of this online, as DEMs are typically shared as PNG files. However, an image only provides incomplete information about a terrain: there is no way to know the world space extent nor the altitude range. It is thus not unusual to see online posts with terrains exaggerated vertically or horizontally. This is a good reminder that terrains are not images.</p> <p> Example of images representing terrains, with no way of telling what is the actual horizontal and vertical extents. Left is a DEM of the Alps with a 12km horizontal extent, and a altitude range of [205, 4805] meters. Right is a procedural ridge noise baked with no real world-space dimensions. </p> <p>There is no real solution to this problem, except that you should provide additional information alongside the image file of your heightfield. Image files are still vastly used because they are easy to share and can be opened and edited using various softwares. </p>"},{"location":"terrain/intro/#appendix-going-further","title":"Appendix: Going further","text":"<p>Different models were developed throughout the years to represent a terrain on a computer - for the discrete case we covered regular heightfields, which are the most popular representation, but there are others that I did not cover:</p> <ul> <li>Hexagon and triangular fields [Dixon et al. 1994]</li> <li>Combinatorial maps [Crespin et al. 2014]</li> </ul>"},{"location":"terrain/intro/#associated-files","title":"Associated files","text":"<p>Files associated with this page are available here.</p>"},{"location":"terrain/procedural/designing_operators/","title":"Designing operators","text":""},{"location":"terrain/procedural/designing_operators/#designing-operators","title":"Designing operators","text":""},{"location":"terrain/procedural/designing_operators/#enhancing-a-single-primitive","title":"Enhancing a single primitive","text":"<p>TODO: talk about transformation, warping, noise addition maybe?</p>"},{"location":"terrain/procedural/designing_operators/#combining-multiple-primitives-together","title":"Combining multiple primitives together","text":"<p>TODO: show a blend operator and a replace. </p>"},{"location":"terrain/procedural/designing_operators/#going-further","title":"Going further","text":"<p>TODO: exercise for the reader to design a new operator, such as ??? Find an idea.</p>"},{"location":"terrain/procedural/designing_primitives/","title":"Designing primitives","text":""},{"location":"terrain/procedural/designing_primitives/#combining-noise-and-primitives","title":"Combining Noise and Primitives","text":"<p>TODO: noise is not enough for creating realistic terrains. However, a combination of different noise can create much more interesting results, provided that we have and can design primitives that represent some specific landforms.</p>"},{"location":"terrain/procedural/designing_primitives/#geometric-skeletons","title":"Geometric Skeletons","text":"<p>TODO: explain point, disk, and curve skeleton. Provide distance formula for all? Or find a JS package that does that. Shade 3D Canvas with colors on the ground to show the weight.</p>"},{"location":"terrain/procedural/designing_primitives/#simple-primitives","title":"Simple Primitives","text":"<p>TODO: The most basic example of a compact primitive is a noise combined with a simple skeleton, such as a point. This limits the influence of the noise in space, and allows to use something else elsewhere in the scene.</p>"},{"location":"terrain/procedural/designing_primitives/#curve-based-primitive","title":"Curve-based primitive","text":"<p>TODO: show a river carved on a plane.</p>"},{"location":"terrain/procedural/designing_primitives/#designing-meta-primitives","title":"Designing Meta Primitives","text":"<p>It is possible to use procedural noise, or even simpler trigonometric functions to create interesting shapes. For instance, transverse dunes, which are very common in arid deserts, can be modeled using a cosinus function. Another cool example is the crater primitive. Show that we are only limited to our imagination, and our knowledge in Maths. Mention Desmos as a useful tool for playing with mathematical functions, which are just like building blocks that we manipulate. For all these examples, show the function written in Latex next to the example.</p>"},{"location":"terrain/procedural/designing_primitives/#going-further","title":"Going further","text":"<p>TODO: do a small exercice where the reader must design a canyon primitive between two points. Parameters must be easy to manipulate while retaining expressivity for the end user.</p>"},{"location":"terrain/procedural/noise_for_terrains/","title":"Noise for terrains","text":""},{"location":"terrain/procedural/noise_for_terrains/#using-noise-for-terrain-generation","title":"Using Noise for Terrain Generation","text":"<p>Noise is a powerful tool that has been applied in many (if not all) subdomains of Computer Graphics. Terrain generation is no exception. In fact, using noise to generate mountains was one of the first application, going back as far as the late eighties with the seminal work of Kenton Musgrave. </p> <p>For terrains, the core idea is to use the scalar value returned by the noise as the altitude at a given point. You can think of this as a world-space plane, with the elevation of points defined by the noise function. Below is an example of the same noise rendered on a 2D texture and on a 3D mesh.</p> <p> </p> <p>Now let's see how to do that in practice. </p> <p>Note</p> <p>If you want to dig into the details of how noise functions work, please refer to this page.</p>"},{"location":"terrain/procedural/noise_for_terrains/#our-first-noise-based-terrain","title":"Our first noise-based terrain","text":"<p>Noise functions are simply dependent on the position at which they are evaluated - they thus belong to the category of procedural functions, as they are no or very few data and instead rely on a procedure to compute a scalar value. If we extend our ProceduralHeightField class introduced in the previous part, we can now define the Elevation function again using our Perlin noise:</p> <pre><code>class ProceduralHeightField extends BaseHeightField {\n    constructor(horizontalExtents, verticalExtents) {\n        super(horizontalExtents, verticalExtents);\n    }\n\n    // Compute the altitude of a 2D point procedurally using Perlin noise\n    Elevation(p) {\n        return perlin.noise(x, y, 0.0);\n    }\n}\n</code></pre> <p>This gives us the following result. Use the mouse to turn around it!</p> <p>Tip</p> <p>For the noise function itself, we use Three.js Perlin noise implementation, which was itself used to showcase a procedural terrain here with the code here.</p> <p>At this point you may not really believe that noise function can be used to create realistic (or at least, visually appealing) terrains. You can play around with the amplitude, frequency, and number of octaves in the example above and will probably improve the results quite a lot. However, noise-based terrains still have several limitations. </p>"},{"location":"terrain/procedural/noise_for_terrains/#the-issues-of-noise","title":"The issues of Noise","text":"<p>Creating terrains using this kind of fractal noise has been done extensively in video games for multiple decades. While you can definitely get a mountainous look for your terrain, getting a proper valley for instance might be more difficult, or even impossible if you're limited to simple, uniform fractal noise. If we were to list all the limitations of the above example, it would look like this:</p> <ul> <li> <p>No valleys: you either get a very mountainous terrain or a very flat terrain, but having a mix of both is difficult.</p> </li> <li> <p>You may notice the same kinds of pattern everywhere. This is one interesting property of noise function: self-similarity. In our case, it's also a limitation.</p> </li> <li> <p>Mountains are only just isolated peaks, lacking ridge structures typically found in real mountain ranges.</p> </li> </ul> <p>In the end, it seems that noise is only capable of generating small bumps. Can we alleviate this issue somehow?</p>"},{"location":"terrain/procedural/noise_for_terrains/#multifractals","title":"Multifractals","text":"<p>Some of these problems can be partially solved by using a more advanced technique called a multifractal noise. The core idea is to modulate the amplitude of successive octave based on previous iterations. This way, areas with a low amplitude will never get too spiky, but instead remain relatively flat, and the opposite will happen for mountainous areas. The example below shows different types of noise for generating terrain shapes, including classical perlin and ridge noise, as well as their multifractal variants. Play around with the different settings to get a feel of how noise behaves.</p> <p>Multifractals still do not solve everything. However, the idea of using procedural functions to generate shapes is interesting and can be pushed further: what if we could create function to represent dunes, cliffs, mountains, mountain ridges, rivers, and more? This will be the subject of the following chapters, where we will try to design a small library of primitives and operators to create more visually interesting and varied terrains.</p>"},{"location":"terrain/procedural/noise_for_terrains/#going-further","title":"Going further","text":"<p>If you want to go further, you may try to use other kinds of noise to create terrains, for instance Worley (or cellular) noise, its fractal variants, or try to model different effects such as domain warp. </p>"},{"location":"terrain/procedural/noise_for_terrains/#associated-files","title":"Associated files","text":"<p>Files associated with this page are available here.</p>"},{"location":"terrain/procedural/terrain_construction_tree/","title":"Terrain construction tree","text":""},{"location":"terrain/procedural/terrain_construction_tree/#terrain-construction-trees","title":"Terrain Construction Trees","text":"<p>TODO: introduce the more formal notion of construction tree, or graph of primitive and operators. This is very classical paradigm in procedural modeling, and in computer graphics in general. These structures have interesting properties, their queries can be optimized, and they can be extended with as many primitives and operators that you may design.</p>"},{"location":"terrain/procedural/terrain_construction_tree/#going-further","title":"Going Further","text":"<ul> <li>Cite JD thesis as a reference (in french though), and the associated article.</li> <li>Cite multi-material extensions with other trees to represent vegetation or water for instance.</li> </ul>"},{"location":"terrain/simulation/simulation_intro/","title":"Introduction","text":""},{"location":"terrain/texturing/texturing_intro/","title":"Introduction","text":""},{"location":"terrain/volumetric/going_3D/","title":"What is a Volumetric Terrain?","text":""},{"location":"terrain/volumetric/implicits/","title":"Using Implicit Surfaces","text":""},{"location":"terrain/volumetric/voxels/","title":"Using Voxels","text":""}]}